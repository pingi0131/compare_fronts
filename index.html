<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8">
  <title>fronts' compare & metrics</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
  <script>
    // 偵測是否為舊瀏覽器（缺少 ES6 關鍵功能）
    if (!window.Promise || !Array.prototype.find) { // 這裡以 Promise 和 Array.prototype.find 為代表特徵
      var s = document.createElement('script');
      s.src = 'https://polyfill.io/v3/polyfill.min.js?features=es6';
      s.defer = true; // 加上 defer，避免阻塞畫面渲染
      document.head.appendChild(s);
    }
  </script>

  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <!-- 添加 KD-Tree 函數庫 -->
  <script>
    // 將 KD-Tree 實現直接內嵌到頁面
    // 基於 https://github.com/ubilabs/kd-tree-javascript
    (function (root, factory) {
      if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
      } else if (typeof exports === 'object') {
        factory(exports);
      } else {
        factory((root.kdt = {}));
      }
    }(this, function (exports) {
      function Node(obj, dimension, parent) {
        this.obj = obj;
        this.left = null;
        this.right = null;
        this.parent = parent;
        this.dimension = dimension;
      }

      function kdTree(points, metric, dimensions) {
        var self = this;

        function buildTree(points, depth, parent) {
          var dim = depth % dimensions.length,
            median,
            node;

          if (points.length === 0) {
            return null;
          }
          if (points.length === 1) {
            return new Node(points[0], dim, parent);
          }

          points.sort(function (a, b) {
            return a[dimensions[dim]] - b[dimensions[dim]];
          });

          median = Math.floor(points.length / 2);
          node = new Node(points[median], dim, parent);
          node.left = buildTree(points.slice(0, median), depth + 1, node);
          node.right = buildTree(points.slice(median + 1), depth + 1, node);

          return node;
        }

        this.root = buildTree(points, 0, null);

        this.nearest = function (point, maxNodes, maxDistance) {
          var i,
            result,
            bestNodes;

          bestNodes = new BinaryHeap(
            function (e) { return -e[1]; }
          );

          function nearestSearch(node) {
            var bestChild,
              dimension = dimensions[node.dimension],
              ownDistance = metric(point, node.obj),
              linearPoint = {},
              linearDistance,
              otherChild,
              i;

            function saveNode(node, distance) {
              bestNodes.push([node, distance]);
              if (bestNodes.size() > maxNodes) {
                bestNodes.pop();
              }
            }

            for (i = 0; i < dimensions.length; i += 1) {
              if (i === node.dimension) {
                linearPoint[dimensions[i]] = point[dimensions[i]];
              } else {
                linearPoint[dimensions[i]] = node.obj[dimensions[i]];
              }
            }

            linearDistance = metric(linearPoint, node.obj);

            if (node.right === null && node.left === null) {
              if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                saveNode(node.obj, ownDistance);
              }
              return;
            }

            if (node.right === null) {
              bestChild = node.left;
            } else if (node.left === null) {
              bestChild = node.right;
            } else {
              if (point[dimension] < node.obj[dimension]) {
                bestChild = node.left;
              } else {
                bestChild = node.right;
              }
            }

            nearestSearch(bestChild);

            if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
              saveNode(node.obj, ownDistance);
            }

            if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {
              if (bestChild === node.left) {
                otherChild = node.right;
              } else {
                otherChild = node.left;
              }
              if (otherChild !== null) {
                nearestSearch(otherChild);
              }
            }
          }

          if (maxDistance) {
            for (i = 0; i < maxNodes; i += 1) {
              bestNodes.push([null, maxDistance]);
            }
          }

          if (self.root) {
            nearestSearch(self.root);
          }

          result = [];

          for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {
            if (bestNodes.content[i][0]) {
              result.push([bestNodes.content[i][0], bestNodes.content[i][1]]);
            }
          }
          return result;
        };
      }

      function BinaryHeap(scoreFunction) {
        this.content = [];
        this.scoreFunction = scoreFunction;
      }

      BinaryHeap.prototype = {
        push: function (element) {
          this.content.push(element);
          this.bubbleUp(this.content.length - 1);
        },

        pop: function () {
          var result = this.content[0];
          var end = this.content.pop();
          if (this.content.length > 0) {
            this.content[0] = end;
            this.sinkDown(0);
          }
          return result;
        },

        peek: function () {
          return this.content[0];
        },

        size: function () {
          return this.content.length;
        },

        bubbleUp: function (n) {
          var element = this.content[n],
            score = this.scoreFunction(element);
          while (n > 0) {
            var parentN = Math.floor((n + 1) / 2) - 1,
              parent = this.content[parentN];
            if (score >= this.scoreFunction(parent)) {
              break;
            }
            this.content[parentN] = element;
            this.content[n] = parent;
            n = parentN;
          }
        },

        sinkDown: function (n) {
          var length = this.content.length,
            element = this.content[n],
            elemScore = this.scoreFunction(element);

          while (true) {
            var child2N = (n + 1) * 2,
              child1N = child2N - 1;
            var swap = null;
            var child1Score;
            if (child1N < length) {
              var child1 = this.content[child1N];
              child1Score = this.scoreFunction(child1);
              if (child1Score < elemScore) {
                swap = child1N;
              }
            }

            if (child2N < length) {
              var child2 = this.content[child2N],
                child2Score = this.scoreFunction(child2);
              if (child2Score < (swap === null ? elemScore : child1Score)) {
                swap = child2N;
              }
            }

            if (swap === null) {
              break;
            }

            this.content[n] = this.content[swap];
            this.content[swap] = element;
            n = swap;
          }
        }
      };

      exports.kdTree = kdTree;
      exports.BinaryHeap = BinaryHeap;
    }));
  </script>

  <script>
    window.MathJax = {
      chtml: { scale: 1.5 } // 放大 200%
    };
  </script>

  <style>
    body {
      font-family: '標楷體', 'Times New Roman', serif;
      padding: 28px;
    }

    #chart-container {
      width: 100%;
      max-width: 960px;
      aspect-ratio: 16 / 10;
      margin: 20px auto 0;
      /* 預設不居中，只有垂直方向有間距 */
      display: none;
      /* 預設不顯示圖表 */
    }


    canvas {
      width: 100% !important;
      height: auto !important;
    }

    h1 {
      margin-top: 0px;
      /* 調整這個數值來控制距離上方的空白 */
      margin-bottom: 20px;
      /* 如果需要控制下方的距離可以修改這裡 */
    }

    .controls,
    .range-controls {
      font-size: 20px;
      margin: 12px 0;
    }

    .controls input[type="file"] {
      font-size: 18px;
      /* 放大檔案選擇按鈕 */
    }

    .range-controls label,
    .range-controls input[type="number"],
    .range-controls button {
      font-size: 18px;
      font-family: "標楷體", "PMingLiU", serif;
      /* 標楷體常用的字體名稱是 PMingLiU */
      font-weight: bold;
    }

    /* 按鈕樣式 */
    .reset-range-btn {
      background-image: url('./png/reset.png');
      /* 設置圖片路徑 */
      background-size: 130%;
      /* 調整圖片大小，根據需要調整比例 */
      background-repeat: no-repeat;
      background-position: center;
      width: 30px;
      height: 30px;
      border: none;
      /* 去掉預設邊框 */
      outline: none;
      /* 去掉按鈕的輪廓 */
      padding: 0;
      /* 去掉內邊距 */
      margin: 0;
      /* 去掉外邊距 */
      cursor: pointer;
      /* 滑鼠移動到按鈕時變成手形 */
      position: relative;
      /* 使用相對定位以便顯示文字 */
      display: inline-block;
      /* 讓按鈕和圖片並排顯示 */
      background-color: transparent;
      /* 背景設為透明，確保圖片顯示清晰 */
      vertical-align: middle;
      /* 垂直對齊到中間 */
    }


    /* 按鈕懸停顯示文字 */
    .reset-range-btn:hover::after {
      content: "reset";
      /* 設定懸停顯示的文字 */
      position: absolute;
      /* 絕對定位 */
      top: 100%;
      /* 文字顯示在按鈕下方 */
      left: 50%;
      /* 文字居中 */
      transform: translateX(-50%);
      /* 精確居中對齊 */
      font-size: 20px;
      /* 設定文字大小 */
      color: black;
      /* 文字顏色 */
      padding: 5px;
      background-color: white;
      /* 背景顏色 */
      border-radius: 5px;
      /* 設定邊角圓滑 */
      box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
      /* 增加陰影效果 */
      white-space: nowrap;
      /* 防止文字換行 */
    }


    /* 按下時的效果 */
    .reset-range-btn:active {
      transform: scale(0.9);
      /* 按下時稍微縮小 */
    }

    .tilde {
      font-size: 1.5em;
      /* 放大 ~ 符號 */
      vertical-align: middle;
      /* 垂直對齊中間 */
    }

    .file-entry {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px;
      margin: 6px 0;
    }

    .math-label {
      font-size: 28px;
      /* 放大字體大小 */
    }

    input[type="color"],
    input[type="text"],
    input[type="number"] {
      padding: 2px 4px;
    }

    input[type="number"] {
      width: 80px;
      padding: 2px 4px;
      font-size: 0.9em;
      height: 30px;
      /* 設定input高度和按鈕相同 */
      vertical-align: middle;
      /* 讓input垂直對齊 */
    }

    button {
      background-color: #c00;
      color: white;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 4px;
    }

    button:hover {
      background-color: #900;
    }

    .reset-btn {
      margin-left: 4px;
      background-color: #007BFF;
    }

    .reset-btn:hover {
      background-color: #0056b3;
    }

    .metrics-results {
      margin-top: 20px;
      font-family: monospace;
      background: #f0f0f0;
      padding: 10px;
      border-radius: 6px;
      white-space: pre;
    }

    #metricsTable {
      font-family: monospace;
      font-size: 16px;
      text-align: center;
      table-layout: fixed;
      /* 確保等寬 */
      width: 100%;
    }

    #metricsTable th,
    #metricsTable td {
      padding: 10px;
      border: 1px solid #ccc;
      overflow: hidden;
      /* 防止內容溢出 */
      text-overflow: ellipsis;
      /* 長內容顯示省略號 */
      white-space: nowrap;
      /* 防止換行 */
    }

    #metricsTable th {
      background-color: #f0f0f0;
      font-weight: bold;
    }

    /* 等寬設置：每欄均分寬度 */
    #metricsTable th,
    #metricsTable td {
      width: calc(100% / 7);
      /* 7 欄均分 */
    }

    /* 紅色高亮樣式 */
    #metricsTable td.best {
      color: red;
      font-weight: bold;
    }

    /* 共前緣行樣式 */
    #metricsTable tr.combined-front {
      background-color: #e0f0ff;
      /* 淺藍色背景區分共前緣 */
      font-weight: bold;
    }

    #metricsTable tbody tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    #metricsTable tbody tr:hover {
      background-color: #e0e0e0;
    }
  </style>
</head>

<body>
  <h1>多檔前緣比較圖 指標計算</h1>

  <!-- 座標區間設定 -->
  <div class="range-controls">
    <label class="math-label">\( f_1(x) \)</label>
    <input type="number" id="minRisk" placeholder="Min" step="1">
    <button class="reset-range-btn" onclick="resetField('minRisk')"></button>
    <span class="tilde">-</span>
    <input type="number" id="maxRisk" placeholder="Max" step="1">
    <button class="reset-range-btn" onclick="resetField('maxRisk')"></button>
    &nbsp;&nbsp;
    <label>\( f_2(x) \)</label>
    <input type="number" id="minProfit" placeholder="Min" step="1">
    <button class="reset-range-btn" onclick="resetField('minProfit')"></button>
    <span class="tilde">-</span>
    <input type="number" id="maxProfit" placeholder="Max" step="1">
    <button class="reset-range-btn" onclick="resetField('maxProfit')"></button>
    &nbsp;&nbsp;
    <button class="reset-btn" onclick="resetAllRanges()">All</button>
  </div>

  <div class="controls">
    <label>選擇 CSV 檔案：</label>
    <input type="file" id="csvFileInput" accept=".csv" multiple />
  </div>

  <div id="fileListContainer" class="controls"></div>
  <button class="reset-btn" onclick="resetColors()">重置所有顏色</button>
  <div id="chart-container">
    <canvas id="riskProfitChart"></canvas>
  </div>
  <div id="metricsOutput" class="metrics-results" style="display: none;"></div>
  <button id="showTableBtn" class="reset-btn" style="display: none;">顯示統整好看表格</button>
  <div id="metricsTableContainer" style="display: none; margin-top: 20px;">
    <table id="metricsTable" border="1"
      style="border-collapse: collapse; width: 100%; max-width: 960px; margin: 0 auto;">
      <thead>
        <tr>
          <th>前緣名稱</th>
          <th>#NDS</th>
          <th>HV</th>
          <th>HV Rate</th>
          <th>Hit Rate</th>
          <th>GD</th>
          <th>IGD</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    let chartInstance = null;
    const datasetMap = new Map();
    const defaultColors = ['#0000FF', '#FFA500', '#888888', '#FF0000', '#00AA00'];
    let combinedFront = null; // 用於存儲計算得到的共前緣

    const minRiskInput = document.getElementById('minRisk');
    const maxRiskInput = document.getElementById('maxRisk');
    const minProfitInput = document.getElementById('minProfit');
    const maxProfitInput = document.getElementById('maxProfit');

    const defaultRanges = {
      minRisk: undefined,
      maxRisk: undefined,
      minProfit: undefined,
      maxProfit: undefined
    };

    [minRiskInput, maxRiskInput, minProfitInput, maxProfitInput].forEach(input => {
      input.addEventListener('blur', drawChart);
      input.addEventListener('keypress', e => { if (e.key === 'Enter') drawChart(); });
    });

    function resetField(fieldId) {
      document.getElementById(fieldId).value = defaultRanges[fieldId] ?? '';
      // Only draw chart if there is data
      if (datasetMap.size > 0) {
        drawChart();
      }
    }

    function resetAllRanges() {
      for (const key in defaultRanges) {
        document.getElementById(key).value = defaultRanges[key] ?? '';
      }
      // Only draw chart if there is data
      if (datasetMap.size > 0) {
        drawChart();
      }
    }

    function resetColors() {
      const entries = Array.from(datasetMap.entries());

      entries.forEach(([fileName, data], index) => {
        const newColor = defaultColors[index % defaultColors.length] || '#000000';
        data.color = newColor;

        // 更新對應 input 的顏色值
        const entryDiv = document.getElementById(`entry-${CSS.escape(fileName)}`);
        if (entryDiv) {
          const colorInput = entryDiv.querySelector('input[type="color"]');
          if (colorInput) colorInput.value = newColor;
        }
      });

      // Only draw chart if there is data
      if (datasetMap.size > 0) {
        drawChart();
      }
    }

    // Improved normalization function that matches Python implementation
    function normalize(data) {
      // Find min and max values across all datasets
      const allRisks = Object.values(data).flatMap(d => d.risk);
      const allProfits = Object.values(data).flatMap(d => d.profit);

      const minRisk = Math.min(...allRisks);
      const maxRisk = Math.max(...allRisks) * 1.01; // Add 1% margin as in Python code
      const minProfit = Math.min(...allProfits) * 0.99; // Subtract 1% margin as in Python code
      const maxProfit = Math.max(...allProfits);

      console.log(`Normalization bounds: min risk:${minRisk}, max risk:${maxRisk}, min profit:${minProfit}, max profit:${maxProfit}`);

      const result = {};
      for (const name in data) {
        const normalizedRisk = [];
        const normalizedProfit = [];

        for (let i = 0; i < data[name].risk.length; i++) {
          const risk = data[name].risk[i];
          const profit = data[name].profit[i];

          const newRisk = (risk - minRisk) / (maxRisk - minRisk);
          const newProfit = (profit - minProfit) / (maxProfit - minProfit);

          normalizedRisk.push(newRisk);
          normalizedProfit.push(newProfit);
        }

        result[name] = {
          risk: normalizedRisk,
          profit: normalizedProfit
        };
      }
      return result;
    }

    // Improved combined front calculation matching Python implementation
    function combineNonDominatedSets(dataSets) {
      const combinedRisk = [];
      const combinedProfit = [];

      // Iterate through all datasets
      for (const [_, dataSet] of dataSets.entries()) {
        for (let i = 0; i < dataSet.data.length; i++) {
          const risk = dataSet.data[i].x;
          const profit = dataSet.data[i].y;

          let addNew = true;
          let j = 0;

          while (j < combinedRisk.length) {
            // If current point is dominated by an existing point, don't add
            if (profit <= combinedProfit[j] && risk >= combinedRisk[j]) {
              addNew = false;
              break;
            }

            // If current point dominates an existing point, remove that existing point
            if (profit > combinedProfit[j] && risk < combinedRisk[j]) {
              combinedRisk.splice(j, 1);
              combinedProfit.splice(j, 1);
            } else {
              j++;
            }
          }

          // If current point is not dominated by any existing point, add it
          if (addNew) {
            combinedRisk.push(risk);
            combinedProfit.push(profit);
          }
        }
      }

      // Sort results by risk (ascending)
      const sortedPairs = combinedRisk.map((risk, i) => [risk, combinedProfit[i]])
        .sort((a, b) => a[0] - b[0]);

      const sortedRisk = sortedPairs.map(pair => pair[0]);
      const sortedProfit = sortedPairs.map(pair => pair[1]);

      return {
        risk: sortedRisk,
        profit: sortedProfit
      };
    }

    function calcGD(normalized, frontKey) {
      const result = {};
      // Get the combined front
      const normalizedFront = {
        risk: normalized[frontKey].risk,
        profit: normalized[frontKey].profit
      };

      for (const name in normalized) {
        const data = normalized[name];
        let sumMin = 0.0;

        // For each point in the current solution set
        for (let i = 0; i < data.risk.length; i++) {
          const risk = data.risk[i];
          const profit = data.profit[i];
          let minDis = Infinity;

          // Find the minimum distance to any point in the reference front
          for (let j = 0; j < normalizedFront.risk.length; j++) {
            const pRisk = normalizedFront.risk[j];
            const pProfit = normalizedFront.profit[j];
            const distance = Math.sqrt(Math.pow(pRisk - risk, 2) + Math.pow(pProfit - profit, 2));

            if (distance < minDis) {
              minDis = distance;
            }
          }

          sumMin += Math.pow(minDis, 2);
        }

        // GD is the square root of the sum of squared minimum distances divided by the number of points
        result[name] = Math.sqrt(sumMin) / data.risk.length;
      }

      return result;
    }

    // IGD calculation: exact match to Python implementation
    function calcIGD(normalized, frontKey) {
      const result = {};
      // Get the combined front
      const normalizedFront = {
        risk: normalized[frontKey].risk,
        profit: normalized[frontKey].profit
      };

      for (const name in normalized) {
        const data = normalized[name];
        let sumMin = 0.0;

        // For each point in the reference front
        for (let j = 0; j < normalizedFront.risk.length; j++) {
          const pRisk = normalizedFront.risk[j];
          const pProfit = normalizedFront.profit[j];
          let minDis = Infinity;

          // Find the minimum distance to any point in the current solution set
          for (let i = 0; i < data.risk.length; i++) {
            const risk = data.risk[i];
            const profit = data.profit[i];
            const distance = Math.sqrt(Math.pow(pRisk - risk, 2) + Math.pow(pProfit - profit, 2));

            if (distance < minDis) {
              minDis = distance;
            }
          }

          sumMin += Math.pow(minDis, 2);
        }

        // IGD is the square root of the sum of squared minimum distances divided by the number of reference points
        result[name] = Math.sqrt(sumMin) / normalizedFront.risk.length;
      }

      return result;
    }

    // HV calculation with proper reference point at (1,0)
    function calcHV(normalized) {
      const result = {};
      const refPointX = 1.0;
      const refPointY = 0.0;

      for (const name in normalized) {
        let hv = 0;
        const r = normalized[name].risk;
        const p = normalized[name].profit;

        // Sort data points by risk (ascending)
        const sortedIndices = Array.from({ length: r.length }, (_, i) => i)
          .sort((a, b) => r[a] - r[b]);

        let prevProfit = refPointY;

        for (const idx of sortedIndices) {
          const risk = r[idx];
          const profit = p[idx];

          // Calculate area contribution
          if (profit > prevProfit) {
            hv += Math.abs((refPointX - risk) * (profit - prevProfit));
            prevProfit = profit;
          }
        }

        result[name] = hv;
      }
      return result;
    }

    function calculateHitRate(normalized) {
      const hitRate = {};
      const hitCounts = {}; // New object to store the raw counts
      const coRisk = normalized["Combined Front"].risk;
      const numCo = coRisk.length; // Total number of points in combined front

      for (const name in normalized) {
        let time = 0; // Number of hits/matches
        const otherRisk = normalized[name].risk;

        // Check if each risk value is in the combined front's risk values
        for (const r of otherRisk) {
          // Use floating point comparison, considering precision issues
          if (coRisk.some(coR => Math.abs(coR - r) < 1e-10)) {
            time += 1;
          }
        }

        // Hit Rate = (matches / total points in combined front) * 100
        hitRate[name] = numCo > 0 ? (time / numCo) * 100 : 0;

        // Store the raw counts for display
        hitCounts[name] = {
          hits: time,
          total: numCo
        };
      }

      return {
        percentages: hitRate,
        counts: hitCounts
      };
    }

    // 按鈕點擊事件
    document.getElementById('showTableBtn').addEventListener('click', () => {
      // 檢查前緣數量
      if (datasetMap.size < 2) {
        alert('請至少上傳兩個前緣檔案以顯示指標表格！');
        return;
      }

      // 檢查是否所有前緣都有名稱
      if (!checkAllNames()) {
        alert('請先為所有前緣輸入名稱！');
        return;
      }

      // 重新計算指標並生成表格
      calculateMetrics();
      generateMetricsTable();
    });

    function calculateMetrics() {
      const showTableBtn = document.getElementById('showTableBtn');
      if (datasetMap.size < 2) {
        document.getElementById('metricsOutput').style.display = 'none';
        document.getElementById('metricsTableContainer').style.display = 'none';
        showTableBtn.style.display = 'none';
        return;
      }

      // Format raw data from datasetMap
      const rawData = {};
      datasetMap.forEach((value, key) => {
        rawData[key] = {
          risk: value.data.map(d => d.x),
          profit: value.data.map(d => d.y)
        };
      });

      // Calculate combined front first
      const combinedFrontData = combineNonDominatedSets(datasetMap);

      // Add combined front to raw data
      rawData["Combined Front"] = {
        risk: combinedFrontData.risk,
        profit: combinedFrontData.profit
      };

      // Normalize all data including the combined front
      const normalized = normalize(rawData);

      try {
        // Calculate metrics
        const HV = calcHV(normalized);
        const GD = calcGD(normalized, "Combined Front");
        const IGD = calcIGD(normalized, "Combined Front");
        const hitRate = calculateHitRate(normalized);

        // Calculate HV Rate
        const combinedHV = HV["Combined Front"];
        const HVR = {};
        for (const name in HV) {
          HVR[name] = combinedHV > 0 ? (HV[name] / combinedHV) * 100 : 0;
        }

        let output = '';
        for (const name of Object.keys(normalized)) {
          const pointCount = name === "Combined Front" ? combinedFrontData.risk.length : datasetMap.get(name)?.data.length || 0;
          const hv = HV[name].toFixed(4);
          const gd = GD[name].toExponential(2);
          const igd = IGD[name].toExponential(2);
          const hvFormat = HV[name].toFixed(20);
          const gdFormat = GD[name].toFixed(20);
          const igdFormat = IGD[name].toFixed(20);
          const hvRate = HVR[name].toFixed(2);
          const hit = hitRate[name].toFixed(2);

          output += `${name}\nPoints: ${pointCount}\nHV:  ${hv} (${hvFormat})\nGD:  ${gd} (${gdFormat})\nIGD: ${igd} (${igdFormat})\nHV Rate: ${hvRate}%\nHit Rate: ${hit}%\n\n`;
        }

        const panel = document.getElementById('metricsOutput');
        panel.textContent = output.trim();
        panel.style.display = 'block';
        showTableBtn.style.display = 'inline-block';

        // 日誌：檢查輸出的前緣數量
        console.log(`Generated metrics for ${Object.keys(normalized).length} fronts (including Combined Front)`);

        // Save calculated combined front for chart display
        combinedFront = combinedFrontData;

        // 隱藏表格直到按鈕被點擊
        document.getElementById('metricsTableContainer').style.display = 'none';
      } catch (e) {
        console.error("Error calculating metrics:", e);
        document.getElementById('metricsOutput').textContent = "Error calculating metrics: " + e.message;
        document.getElementById('metricsOutput').style.display = 'block';
        showTableBtn.style.display = 'none';
        document.getElementById('metricsTableContainer').style.display = 'none';
      }
    }

    // 檢查所有前緣是否有名稱
    // 檢查所有前緣是否有名稱
    function checkAllNames() {
      for (const [fileName, data] of datasetMap) {
        if (!data.name.trim()) {
          return false;
        }
      }
      return true;
    }

    // 解析 metricsOutput 並生成表格
    function generateMetricsTable() {
      // 檢查是否有足夠的前緣
      if (!datasetMap || datasetMap.size < 2) {
        alert('請至少上傳兩個前緣檔案以顯示指標表格！');
        return;
      }

      // 檢查所有前緣是否有名稱
      if (!checkAllNames()) {
        alert('請先為所有前緣輸入名稱！');
        return;
      }

      // 獲取原始指標數據
      const rawData = {};
      datasetMap.forEach((value, key) => {
        rawData[key] = {
          risk: value.data.map(d => d.x),
          profit: value.data.map(d => d.y)
        };
      });

      // 計算共前緣
      const combinedFrontData = combineNonDominatedSets(datasetMap);
      rawData["Combined Front"] = {
        risk: combinedFrontData.risk,
        profit: combinedFrontData.profit
      };

      // 標準化所有數據
      const normalized = normalize(rawData);

      // 計算所有指標
      const HV = calcHV(normalized);
      const GD = calcGD(normalized, "Combined Front");
      const IGD = calcIGD(normalized, "Combined Front");
      const hitRateResult = calculateHitRate(normalized);
      const hitRate = hitRateResult.percentages;
      const hitCounts = hitRateResult.counts;

      // 計算 HV Rate
      const combinedHV = HV["Combined Front"];
      const HVR = {};
      for (const name in HV) {
        HVR[name] = combinedHV > 0 ? (HV[name] / combinedHV) * 100 : 0;
      }

      // 準備表格數據
      const tableBody = document.getElementById('metricsTable').querySelector('tbody');
      tableBody.innerHTML = ''; // 清空現有內容

      // 存儲指標以找出最佳值（排除共前緣）
      const metricsData = [];
      let combinedFrontMetrics = null;

      // 處理每個前緣的指標
      for (const name in normalized) {
        const pointCount = name === "Combined Front" ?
          combinedFrontData.risk.length :
          datasetMap.get(name)?.data.length || 0;

        const data = {
          fileName: name,
          customName: name === "Combined Front" ? "Combined Front" : datasetMap.get(name)?.name || name,
          points: pointCount,
          hv: HV[name],
          gd: GD[name],
          igd: IGD[name],
          hvRate: HVR[name],
          hitRate: hitRate[name]
        };

        if (name === "Combined Front") {
          combinedFrontMetrics = data;
        } else {
          metricsData.push(data);
        }
      }

      // 找出最佳值（僅限非共前緣）
      const maxNDS = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.points)) : 0;
      const maxHV = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.hv)) : 0;
      const minGD = metricsData.length > 0 ? Math.min(...metricsData.map(d => d.gd)) : Infinity;
      const minIGD = metricsData.length > 0 ? Math.min(...metricsData.map(d => d.igd)) : Infinity;
      const maxHVRate = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.hvRate)) : 0;
      const maxHitRate = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.hitRate)) : 0;

      // 生成非共前緣行
      metricsData.forEach(data => {
        // 安全訪問 hitCounts，提供默認值
        const hitCount = hitCounts[data.fileName] || { hits: 0, total: 0 };

        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${data.customName}</td>
          <td class="${data.points === maxNDS ? 'best' : ''}">${data.points}</td>
          <td class="${data.hv === maxHV ? 'best' : ''}">${data.hv.toFixed(4)}</td>
          <td class="${data.hvRate === maxHVRate ? 'best' : ''}">${data.hvRate.toFixed(2)}%</td>
          <td class="${data.hitRate === maxHitRate ? 'best' : ''}">
            ${data.hitRate.toFixed(2)}%
            <span style="font-size: 0.7em; vertical-align: middle;">
              \\( \\frac{${hitCount.hits}}{${hitCount.total}} \\)
            </span>
          </td>
          <td class="${data.gd === minGD ? 'best' : ''}">${data.gd.toExponential(2)}</td>
          <td class="${data.igd === minIGD ? 'best' : ''}">${data.igd.toExponential(2)}</td>
        `;
        tableBody.appendChild(row);
      });

      // 顯示表格容器
      document.getElementById('metricsTableContainer').style.display = 'block';

      // 渲染數學表達式
      if (window.MathJax) {
        MathJax.typeset();
      }
    }

    // Also, make sure the calculateMetrics function is updated to only show HV, GD, and IGD
    function calculateMetrics() {
      const showTableBtn = document.getElementById('showTableBtn');
      if (datasetMap.size < 2) {
        document.getElementById('metricsOutput').style.display = 'none';
        document.getElementById('metricsTableContainer').style.display = 'none';
        showTableBtn.style.display = 'none';
        return;
      }

      // Format raw data from datasetMap
      const rawData = {};
      datasetMap.forEach((value, key) => {
        rawData[key] = {
          risk: value.data.map(d => d.x),
          profit: value.data.map(d => d.y)
        };
      });

      // Calculate combined front first
      const combinedFrontData = combineNonDominatedSets(datasetMap);

      // Add combined front to raw data
      rawData["Combined Front"] = {
        risk: combinedFrontData.risk,
        profit: combinedFrontData.profit
      };

      // Normalize all data including the combined front
      const normalized = normalize(rawData);

      try {
        // Calculate metrics
        const HV = calcHV(normalized);
        const GD = calcGD(normalized, "Combined Front");
        const IGD = calcIGD(normalized, "Combined Front");
        const hitRateResult = calculateHitRate(normalized);
        const hitRate = hitRateResult.percentages;

        let output = '';
        for (const name of Object.keys(normalized)) {
          // Skip the Combined Front in the output display
          if (name === "Combined Front") {
            continue;
          }

          const hv = HV[name].toFixed(4);
          const gd = GD[name].toExponential(2);
          const igd = IGD[name].toExponential(2);

          // Only show HV, GD, and IGD in the simplified output
          output += `${name}\nHV: ${hv}\nGD: ${gd}\nIGD: ${igd}\n\n`;
        }

        const panel = document.getElementById('metricsOutput');
        panel.textContent = output.trim();
        panel.style.display = 'block';
        showTableBtn.style.display = 'inline-block';

        // Save calculated combined front for chart display
        combinedFront = combinedFrontData;

        // Hide the table until button is clicked
        document.getElementById('metricsTableContainer').style.display = 'none';
      } catch (e) {
        console.error("Error calculating metrics:", e);
        document.getElementById('metricsOutput').textContent = "Error calculating metrics: " + e.message;
        document.getElementById('metricsOutput').style.display = 'block';
        showTableBtn.style.display = 'none';
        document.getElementById('metricsTableContainer').style.display = 'none';
      }
    }

    // 按鈕點擊事件
    document.getElementById('showTableBtn').addEventListener('click', generateMetricsTable);


    document.getElementById('csvFileInput').addEventListener('change', function (e) {
      const files = Array.from(e.target.files);
      files.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = function (event) {
          const text = event.target.result;
          const lines = text.split(/\r?\n/);
          if (lines.length === 0) return;

          const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
          const riskIndex = headers.findIndex(h => h.includes('risk'));
          const profitIndex = headers.findIndex(h => h.includes('profit') || h.includes('return'));
          if (riskIndex === -1 || profitIndex === -1) return;

          const parsedSet = new Set();
          const parsed = [];

          for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue; // 跳過空行

            const cols = line.split(',');
            const x = parseFloat(cols[riskIndex]);
            const y = parseFloat(cols[profitIndex]);
            const key = `${x},${y}`;
            if (!isNaN(x) && !isNaN(y) && !(x === 0 && y === 0) && !parsedSet.has(key)) {
              parsedSet.add(key);
              parsed.push({ x, y });
            }
          }

          if (parsed.length > 0) {
            const color = defaultColors[datasetMap.size % defaultColors.length] || '#000000';
            datasetMap.set(file.name, {
              name: '', data: parsed.sort((a, b) => a.x - b.x),
              color
            });
            addFileEntryUI(file.name, color);
            drawChart(); // drawChart 內會處理共前緣計算
          }
        };
        reader.readAsText(file, 'UTF-8');
      });
      e.target.value = '';
    });

    function addFileEntryUI(fileName, defaultColor) {
      const container = document.getElementById('fileListContainer');
      const entry = document.createElement('div');
      entry.className = 'file-entry';
      entry.id = `entry-${CSS.escape(fileName)}`;

      const colorInput = document.createElement('input');
      colorInput.type = 'color';
      colorInput.value = defaultColor;
      colorInput.style.border = 'none';
      colorInput.style.outline = 'none';
      colorInput.addEventListener('input', () => {
        datasetMap.get(fileName).color = colorInput.value;
        drawChart();
      });

      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.style.width = '80px';
      nameInput.placeholder = '前緣名稱';
      nameInput.value = datasetMap.get(fileName).name || '';
      nameInput.addEventListener('blur', () => {
        datasetMap.get(fileName).name = nameInput.value.trim();
        drawChart();
      });
      nameInput.addEventListener('keypress', e => {
        if (e.key === 'Enter') {
          nameInput.blur();
        }
      });

      const delBtn = document.createElement('button');
      delBtn.textContent = '刪除';
      delBtn.onclick = () => {
        datasetMap.delete(fileName);
        entry.remove();
        drawChart();
      };

      entry.appendChild(colorInput);
      entry.appendChild(nameInput);
      entry.appendChild(document.createTextNode(fileName));
      entry.appendChild(delBtn);
      container.appendChild(entry);
    }

    function drawChart() {
      const ctx = document.getElementById('riskProfitChart').getContext('2d');
      if (chartInstance) chartInstance.destroy();

      // 只有當前緣數量 >= 2 時才計算共前緣
      combinedFront = datasetMap.size >= 2 ? combineNonDominatedSets(datasetMap) : null;

      const datasets = Array.from(datasetMap.entries()).map(([fileName, { data, color, name }]) => ({
        label: name || fileName,
        data: data,
        backgroundColor: color,
        borderColor: color,
        pointRadius: 5,
        showLine: true,
        fill: false,
        tension: 0
      }));

      if (combinedFront && combinedFront.risk.length > 0) {
        const combinedData = [];
        for (let i = 0; i < combinedFront.risk.length; i++) {
          combinedData.push({
            x: combinedFront.risk[i],
            y: combinedFront.profit[i]
          });
        }
        datasets.push({
          label: 'Combined Front',
          data: combinedData,
          backgroundColor: '#000000',
          borderColor: '#000000',
          pointRadius: 5,
          showLine: true,
          fill: false,
          tension: 0,
          borderWidth: 2,
          borderDash: [5, 5]
        });
      }

      const minX = parseFloat(minRiskInput.value);
      const maxX = parseFloat(maxRiskInput.value);
      const minY = parseFloat(minProfitInput.value);
      const maxY = parseFloat(maxProfitInput.value);

      const xMin = isNaN(minX) ? undefined : minX;
      const xMax = isNaN(maxX) ? undefined : maxX;
      const yMin = isNaN(minY) ? undefined : minY;
      const yMax = isNaN(maxY) ? undefined : maxY;

      chartInstance = new Chart(ctx, {
        type: 'scatter',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Compared of Multiple Algorithms',
              font: {
                family: 'Times New Roman',
                size: 32,
                weight: 'bold'
              }
            },
            tooltip: {
              titleFont: {
                family: 'Times New Roman',
                size: 14
              },
              bodyFont: {
                family: 'Times New Roman',
                size: 14
              },
              callbacks: {
                label: function (context) {
                  const label = context.dataset.label;
                  const x = context.parsed.x.toFixed(2);
                  const y = context.parsed.y.toFixed(2);
                  return `${label}: (${x}, ${y})`;
                }
              }
            },
            legend: {
              labels: {
                font: {
                  family: 'Times New Roman',
                  size: 14,
                  weight: 'bold'
                }
              }
            },
            zoom: {
              pan: {
                enabled: true,
                mode: 'xy',
                threshold: 5,
              },
              zoom: {
                wheel: { enabled: true },
                pinch: { enabled: true },
                mode: 'xy',
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Daily Risk',
                font: {
                  family: 'Times New Roman',
                  size: 24,
                  weight: 'bold'
                }
              },
              ticks: {
                font: {
                  family: 'Times New Roman',
                  size: 20,
                  weight: 'bold'
                }
              },
              min: xMin,
              max: xMax
            },
            y: {
              title: {
                display: true,
                text: 'Daily Expected Return',
                font: {
                  family: 'Times New Roman',
                  size: 20,
                  weight: 'bold'
                }
              },
              ticks: {
                font: {
                  family: 'Times New Roman',
                  size: 20,
                  weight: 'bold'
                }
              },
              min: yMin,
              max: yMax
            }
          }
        }
      });

      // 顯示圖表並讓它居中
      document.getElementById('chart-container').style.display = 'block';
      document.getElementById('chart-container').style.margin = '20px auto';
      document.getElementById('chart-container').addEventListener('dblclick', function () {
        chartInstance.resetZoom();
      });
      calculateMetrics();
    }
  </script>
</body>

</html>