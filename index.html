<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <title>fronts' compare & metrics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata@2.2.2/dist/chartjs-plugin-dragdata.min.js"></script>
    <script>
        // 偵測是否為舊瀏覽器（缺少 ES6 關鍵功能）
        if (!window.Promise || !Array.prototype.find) {
            var s = document.createElement('script');
            s.src = 'https://polyfill.io/v3/polyfill.min.js?features=es6';
            s.defer = true;
            document.head.appendChild(s);
        }
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        // KD-Tree implementation (unchanged)
        (function (root, factory) {
            if (typeof define === 'function' && define.amd) {
                define(['exports'], factory);
            } else if (typeof exports === 'object') {
                factory(exports);
            } else {
                factory((root.kdt = {}));
            }
        }(this, function (exports) {
            function Node(obj, dimension, parent) {
                this.obj = obj;
                this.left = null;
                this.right = null;
                this.parent = parent;
                this.dimension = dimension;
            }
            function kdTree(points, metric, dimensions) {
                var self = this;
                function buildTree(points, depth, parent) {
                    var dim = depth % dimensions.length,
                        median,
                        node;
                    if (points.length === 0) {
                        return null;
                    }
                    if (points.length === 1) {
                        return new Node(points[0], dim, parent);
                    }
                    points.sort(function (a, b) {
                        return a[dimensions[dim]] - b[dimensions[dim]];
                    });
                    median = Math.floor(points.length / 2);
                    node = new Node(points[median], dim, parent);
                    node.left = buildTree(points.slice(0, median), depth + 1, node);
                    node.right = buildTree(points.slice(median + 1), depth + 1, node);
                    return node;
                }
                this.root = buildTree(points, 0, null);
                this.nearest = function (point, maxNodes, maxDistance) {
                    var i,
                        result,
                        bestNodes;
                    bestNodes = new BinaryHeap(
                        function (e) { return -e[1]; }
                    );
                    function nearestSearch(node) {
                        var bestChild,
                            dimension = dimensions[node.dimension],
                            ownDistance = metric(point, node.obj),
                            linearPoint = {},
                            linearDistance,
                            otherChild,
                            i;
                        function saveNode(node, distance) {
                            bestNodes.push([node, distance]);
                            if (bestNodes.size() > maxNodes) {
                                bestNodes.pop();
                            }
                        }
                        for (i = 0; i < dimensions.length; i += 1) {
                            if (i === node.dimension) {
                                linearPoint[dimensions[i]] = point[dimensions[i]];
                            } else {
                                linearPoint[dimensions[i]] = node.obj[dimensions[i]];
                            }
                        }
                        linearDistance = metric(linearPoint, node.obj);
                        if (node.right === null && node.left === null) {
                            if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                                saveNode(node.obj, ownDistance);
                            }
                            return;
                        }
                        if (node.right === null) {
                            bestChild = node.left;
                        } else if (node.left === null) {
                            bestChild = node.right;
                        } else {
                            if (point[dimension] < node.obj[dimension]) {
                                bestChild = node.left;
                            } else {
                                bestChild = node.right;
                            }
                        }
                        nearestSearch(bestChild);
                        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                            saveNode(node.obj, ownDistance);
                        }
                        if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {
                            if (bestChild === node.left) {
                                otherChild = node.right;
                            } else {
                                otherChild = node.left;
                            }
                            if (otherChild !== null) {
                                nearestSearch(otherChild);
                            }
                        }
                    }
                    if (maxDistance) {
                        for (i = 0; i < maxNodes; i += 1) {
                            bestNodes.push([null, maxDistance]);
                        }
                    }
                    if (self.root) {
                        nearestSearch(self.root);
                    }
                    result = [];
                    for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {
                        if (bestNodes.content[i][0]) {
                            result.push([bestNodes.content[i][0], bestNodes.content[i][1]]);
                        }
                    }
                    return result;
                };
            }
            function BinaryHeap(scoreFunction) {
                this.content = [];
                this.scoreFunction = scoreFunction;
            }
            BinaryHeap.prototype = {
                push: function (element) {
                    this.content.push(element);
                    this.bubbleUp(this.content.length - 1);
                },
                pop: function () {
                    var result = this.content[0];
                    var end = this.content.pop();
                    if (this.content.length > 0) {
                        this.content[0] = end;
                        this.sinkDown(0);
                    }
                    return result;
                },
                peek: function () {
                    return this.content[0];
                },
                size: function () {
                    return this.content.length;
                },
                bubbleUp: function (n) {
                    var element = this.content[n],
                        score = this.scoreFunction(element);
                    while (n > 0) {
                        var parentN = Math.floor((n + 1) / 2) - 1,
                            parent = this.content[parentN];
                        if (score >= this.scoreFunction(parent)) {
                            break;
                        }
                        this.content[parentN] = element;
                        this.content[n] = parent;
                        n = parentN;
                    }
                },
                sinkDown: function (n) {
                    var length = this.content.length,
                        element = this.content[n],
                        elemScore = this.scoreFunction(element);
                    while (true) {
                        var child2N = (n + 1) * 2,
                            child1N = child2N - 1;
                        var swap = null;
                        var child1Score;
                        if (child1N < length) {
                            var child1 = this.content[child1N];
                            child1Score = this.scoreFunction(child1);
                            if (child1Score < elemScore) {
                                swap = child1N;
                            }
                        }
                        if (child2N < length) {
                            var child2 = this.content[child2N],
                                child2Score = this.scoreFunction(child2);
                            if (child2Score < (swap === null ? elemScore : child1Score)) {
                                swap = child2N;
                            }
                        }
                        if (swap === null) {
                            break;
                        }
                        this.content[n] = this.content[swap];
                        this.content[swap] = element;
                        n = swap;
                    }
                }
            };
            exports.kdTree = kdTree;
            exports.BinaryHeap = BinaryHeap;
        }));
    </script>
    <script>
        window.MathJax = {
            chtml: { scale: 1.5 }
        };
    </script>
    <style>
        body {
            font-family: '標楷體', 'Times New Roman', serif;
            padding: 28px;
            display: flex;
        }

        .date-inputs {
            position: fixed;
            top: 45px;
            right: 0px;
            /* 與側邊欄觸發器對齊 */
            display: flex;
            align-items: center;
            /*gap: 10px;*/
            background-color: #f0f0f0;
            /*padding: 6px;
            border: 1px solid #ccc;
            /*border-radius: 4px;*/
            z-index: 1002;
            /* 高於側邊欄 (z-index: 1000) 和觸發器 (z-index: 1001) */
            border-radius: 4px;
            /* 可選：保持圓角 */
        }

        .date-inputs input[type="number"] {
            width: 60px;
            padding: 3px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
            height: 24px;
        }

        .date-inputs button {
            background-color: #f0f0f0;
            color: #ffffff;
            border: none;
            padding: 1px 1px;
            /* 減少按鈕內邊距 */
            cursor: pointer;
            font-size: 16px;
            font-family: '標楷體', 'PMingLiU', serif;
            width: 30px;
            height: 24px;
            display: flex;
            /* 使用 flex 佈局 */
            justify-content: center;
            /* 水平居中 */
            align-items: center;
            /* 垂直居中 */
            border-radius: 4px;
            /* 保持圓角 */
        }

        .date-inputs button:hover {
            background-color: #ccc;
        }

        .date-inputs button:hover::after {
            background-color: #ffffff;
            content: "Load";
            position: absolute;
            top: 100%;
            right: 0%;
            font-size: 20px;
            color: black;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
        }

        .data-source-container {
            position: fixed;
            top: 10px;
            right: 0px;
            display: flex;
            align-items: center;
            background-color: #f0f0f0;
            border-radius: 4px;
            z-index: 1003;
        }

        .data-source-container select {
            padding: 3px;
            font-size: 20px;
            border: 1px solid #ccc;
            border-radius: 4px;
            height: 35px;
            width: 170px;
            background-color: #fff;
            cursor: pointer;
            font-family: '標楷體', 'Times New Roman', serif;
        }

        .data-source-container select:focus {
            outline: none;
            border-color: #007BFF;
        }

        /* Sidebar styles */
        .sidebar {
            top: 80px;
            width: 110px;
            height: calc(100vh - 122px);
            /* Adjust height to fit */
            overflow-y: auto;
            background-color: #f0f0f0;
            border-top: 1px solid #ccc;
            /* 添加上邊框 */
            border-bottom: 1px solid #ccc;
            /* 添加下邊框 */
            border-left: 1px solid #ccc;
            padding: 10px;
            position: fixed;
            right: -110px;
            /* Hidden by default */
            transition: right 0.3s ease;
            /* Smooth sliding */
            border-radius: 5px;
            z-index: 1000;
        }

        .sidebar.visible {
            right: 0;
            /* Visible when hovered */
        }

        .sidebar-trigger {
            position: fixed;
            right: 0;
            top: 28px;
            width: 20px;
            /* Trigger area */
            height: calc(100vh - 56px);
            background: transparent;
            z-index: 1001;
            cursor: pointer;
        }

        .date-entry {
            padding: 9px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 4px;
            font-size: 20px;
            /* 默認字體大小 */
            text-align: center;
        }

        .date-entry:hover {
            background-color: #e0e0e0;
            font-size: 21px;
            /* 懸停時略微放大 */
        }

        .date-entry:active {
            transform: scale(0.9);
        }

        .date-entry.selected {
            background-color: #007BFF;
            color: white;
            font-weight: bold;
            font-size: 20px;
        }

        /* Main content */
        .main-content {
            margin-right: 20px;
            /* Space for trigger */
            width: calc(100% - 20px);
        }

        #chart-container {
            width: 100%;
            max-width: 960px;
            aspect-ratio: 16 / 10;
            margin: 20px auto 0;
            display: none;
        }

        canvas {
            width: 100% !important;
            height: auto !important;
        }

        h1 {
            margin-top: 0px;
            margin-bottom: 20px;
        }

        .help-link {
            font-family: '標楷體', 'PMingLiU', serif;
            font-size: 30px;
            /* 與 .range-controls 的字體大小一致 */
            color: #9bc5f2;
            /* 藍色，與 .reset-btn 背景色一致<a href= */
            text-decoration: none;
            /* 移除下劃線 */
            margin-left: 10px;
            /* 與 <h1> 保持間距 */
            vertical-align: middle;
            /* 與 <h1> 文字對齊 */
        }

        .help-link:hover {
            color: #0056b3;
            /* 懸停時變深，與 .reset-btn:hover 一致 */
            text-decoration: underline;
            /* 懸停時添加下劃線 */

        }

        .help-link:hover::after {
            content: "使用手冊";
            font-size: 30px;
            color: black;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
            text-decoration: none;
        }

        .controls,
        .range-controls {
            font-size: 20px;
            margin: 12px 0;
        }

        .controls input[type="file"] {
            font-size: 18px;
        }

        .range-controls label,
        .range-controls input[type="number"],
        .range-controls button {
            font-size: 18px;
            font-family: "標楷體", "PMingLiU", serif;
            font-weight: bold;
        }

        .reset-range-btn {
            background-image: url('./png/reset.png');
            background-size: 130%;
            background-repeat: no-repeat;
            background-position: center;
            width: 30px;
            height: 30px;
            border: none;
            outline: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            position: relative;
            display: inline-block;
            background-color: transparent;
            vertical-align: middle;
        }

        .reset-range-btn:hover::after {
            content: "reset";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            color: black;
            padding: 5px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
        }

        .reset-range-btn:active {
            transform: scale(0.9);
        }

        .tilde {
            font-size: 1.5em;
            vertical-align: middle;
        }

        .file-entry {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
            margin: 6px 0;
        }

        .math-label {
            font-size: 28px;
        }

        input[type="text"],
        input[type="number"] {
            padding: 2px 4px;
        }

        input[type="number"] {
            width: 80px;
            padding: 2px 4px;
            font-size: 0.9em;
            height: 30px;
            vertical-align: middle;
        }

        button {
            background-color: #c00;
            color: white;
            border: none;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 4px;
        }

        button:hover {
            background-color: #900;
        }

        .reset-btn {
            margin-left: 4px;
            background-color: #007BFF;
        }

        .reset-btn:hover {
            background-color: #0056b3;
        }

        .metrics-results {
            margin-top: 20px;
            font-family: monospace;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 6px;
            white-space: pre;
        }

        #metricsTable {
            font-family: monospace;
            font-size: 16px;
            text-align: center;
            table-layout: fixed;
            width: 100%;
        }

        #metricsTable th,
        #metricsTable td {
            padding: 10px;
            border: 1px solid #ccc;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #metricsTable th {
            background-color: #f0f0f0;
            font-weight: bold;
        }

        #metricsTable th,
        #metricsTable td {
            width: calc(100% / 7);
        }

        #metricsTable td.best {
            color: red;
            font-weight: bold;
        }

        #metricsTable tr.combined-front {
            background-color: #e0f0ff;
            font-weight: bold;
        }

        #metricsTable tbody tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        #metricsTable tbody tr:hover {
            background-color: #e0e0e0;
        }

        /* Custom Color Picker Modal Styles */
        .color-picker-modal {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            padding: 10px;
            border-radius: 5px;
        }

        .color-picker-tabs {
            display: grid;
            grid-template-columns: repeat(3, 115px);
            border-bottom: 1px solid #ccc;
            margin-bottom: 10px;
        }

        .color-picker-tabs button {
            padding: 5px;
            background: #f0f0f0;
            /* 恢復默認背景色 */
            color: #333333;
            /* 恢復默認文字顏色 */
            border: none;
            cursor: pointer;
            font-size: 14px;
            border-radius: 3px 3px 0 0;
            text-align: center;
            transition: background-color 0.2s ease;
            /* 保持平滑過渡 */
        }

        .color-picker-content input[type="color"] {
            width: 115px;
            height: 40px;
            border: none;
            outline: none;
            cursor: pointer;
            background: transparent;
            padding: 0;
        }

        .color-picker-tabs button.active {
            background: #007BFF;
            color: white;
            border-bottom: 2px solid #0056b3;
        }

        .color-picker-tabs button:hover {
            background: #d0d0d0;
            color: #000000;
        }

        .color-picker-content {
            display: none;
        }

        .color-picker-content.active {
            display: block;
        }

        .common-colors {
            display: grid;
            grid-template-columns: repeat(10, 30px);
            grid-auto-rows: 30px;
            gap: 5px;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            cursor: pointer;
            border-radius: 3px;
        }

        .color-swatch:hover {
            border-color: #000;
        }

        .hexrgb-inputs {
            display: grid;
            gap: 8px;
        }

        .hexrgb-inputs label {
            display: flex;
            align-items: center;
            gap: 8px;
            /* Keep horizontal gap as is or adjust as needed */
            font-size: 14px;
            margin-bottom: 4px;
            /* Reduced from 8px to 4px for less vertical spacing */
            width: 100%;
        }

        .hexrgb-inputs input.rgb-slider {
            width: 115px;
        }

        .hexrgb-inputs input.rgb-slider,
        .hexrgb-inputs input.opacity-slider {
            width: 100%;
        }

        .hexrgb-inputs input.rgb-number,
        .hexrgb-inputs input.opacity-number {
            width: 50px;
            padding: 3px;
            font-size: 14px;
            text-align: right;
        }

        .hexrgb-inputs input.hex-input {
            width: 100%;
            padding: 5px;
            font-family: monospace;
            font-size: 14px;
        }

        .hexrgb-inputs .confirm-btn {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 14px;
            justify-self: center;
        }

        .hexrgb-inputs .confirm-btn:hover {
            background-color: #0056b3;
        }

        .rgb-inputs input {
            width: 60px;
            padding: 3px;
            font-size: 14px;
        }

        .rgb-preview-box {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            display: inline-block;
            vertical-align: middle;
            border-radius: 4px;
            flex-shrink: 0;
            /* Prevent preview box from shrinking */
        }

        .rgb-slider {
            flex: 1;
            /* Take remaining space */
            min-width: 50px;
            /* Ensure slider is usable */
            vertical-align: middle;
        }

        .rgb-number {
            width: 50px;
            padding: 3px;
            font-size: 20px;
            vertical-align: middle;
            flex-shrink: 0;
            /* Prevent number input from shrinking */
            text-align: right;
            /* 文字靠右對齊 */
        }

        .color-preview-box {
            opacity: 1;
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .color-preview-box-list {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            display: inline-block;
            vertical-align: middle;
            cursor: pointer;
            border-radius: 3px;
        }

        .color-preview-box-list:hover {
            border-color: #000;
        }

        .hexrgb-inputs label span {
            font-size: 24px;
            /* 保持字體大小 */
            display: inline-block;
            /* 讓它可以有寬度屬性 */
            width: auto;
            /* 自動寬度根據內容 */
            white-space: nowrap;
            /* 防止換行 */
            font-family: "標楷體", "Times New Roman", serif;
        }
    </style>
</head>

<body>
    <div class="data-source-container">
        <select id="dataSourceSelect">
            <option value="WPM_MoQA" data-min-year="2021" data-min-month="12" data-max-year="2025" data-max-month="4">
                WPM MoQA</option>
            <option value="EPM_H-MoQTS" data-min-year="2023" data-min-month="1" data-max-year="2025" data-max-month="4">
                EPM H-MoQTS</option>
        </select>
    </div>

    <div class="date-inputs">
        <input type="number" id="yearInput" placeholder="Year" min="2023" max="2025" step="1">
        <input type="number" id="monthInput" placeholder="Month" min="1" max="12" step="1">
        <button id="loadDateBtn" class="reset-btn">✔️</button>
    </div>
    <div class="sidebar-trigger" id="sidebarTrigger"></div>
    <div class="sidebar" id="dateSidebar">
        <!-- Date entries will be populated by JavaScript -->
    </div>
    <div class="main-content">
        <h1>多檔前緣比較圖 指標計算<a href="https://pingi0131.github.io/compare_fronts/guide.html" class="help-link">Help</a></h1>

        <div class="range-controls">
            <label class="math-label">\( f_1(x) \)</label>
            <input type="number" id="minRisk" placeholder="Min" step="1">
            <button class="reset-range-btn" onclick="resetField('minRisk')"></button>
            <span class="tilde">-</span>
            <input type="number" id="maxRisk" placeholder="Max" step="1">
            <button class="reset-range-btn" onclick="resetField('maxRisk')"></button>
              
            <label>\( f_2(x) \)</label>
            <input type="number" id="minProfit" placeholder="Min" step="1">
            <button class="reset-range-btn" onclick="resetField('minProfit')"></button>
            <span class="tilde">-</span>
            <input type="number" id="maxProfit" placeholder="Max" step="1">
            <button class="reset-range-btn" onclick="resetField('maxProfit')"></button>
              
            <button class="reset-btn" onclick="resetAllRanges()">All</button>
        </div>
        <div id="fileListContainer" class="controls"></div>
        <button id="resetColorsBtn" class="reset-btn" onclick="resetColors()" style="display: none;">重置所有顏色</button>
        <div id="chart-container">
            <canvas id="riskProfitChart"></canvas>
        </div>
        <div id="metricsOutput" class="metrics-results" style="display: none;"></div>
        <button id="showTableBtn" class="reset-btn" style="display: none; font-size: 14px;">精緻表格</button>
        <div id="metricsTableContainer" style="display: none; margin-top: 20px;">
            <table id="metricsTable" border="1"
                style="border-collapse: collapse; width: 100%; max-width: 960px; margin: 0 auto;">
                <thead>
                    <tr>
                        <th>前緣名稱</th>
                        <th>#NDS</th>
                        <th>HV</th>
                        <th>HV Rate</th>
                        <th>Hit Rate</th>
                        <th>GD</th>
                        <th>IGD</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    <script>
        let chartInstance = null;
        const datasetMap = new Map();
        const defaultColors = ['#0000FF', '#FFA500', '#888888', '#00AA00'];
        let combinedFront = null;

        function filterDataByRange(dataMap, minRisk, maxRisk, minProfit, maxProfit) {
            const filteredMap = new Map();
            dataMap.forEach((value, fileName) => {
                const filteredData = value.data.filter(point => {
                    const x = point.x;
                    const y = point.y;
                    return (
                        (isNaN(minRisk) || x >= minRisk) &&
                        (isNaN(maxRisk) || x <= maxRisk) &&
                        (isNaN(minProfit) || y >= minProfit) &&
                        (isNaN(maxProfit) || y <= maxProfit)
                    );
                });
                if (filteredData.length > 0) {
                    filteredMap.set(fileName, {
                        ...value,
                        data: filteredData
                    });
                }
            });
            return filteredMap;
        }

        // Generate date list
        function generateDateList() {
            const dataSourceSelect = document.getElementById('dataSourceSelect');
            const selectedOption = dataSourceSelect.options[dataSourceSelect.selectedIndex];
            const minYear = parseInt(selectedOption.dataset.minYear);
            const maxYear = parseInt(selectedOption.dataset.maxYear);
            const minMonth = parseInt(selectedOption.dataset.minMonth);
            const maxMonth = parseInt(selectedOption.dataset.maxMonth);

            const dates = [];

            for (let year = maxYear; year >= minYear; year--) {

                // Apply specific min/max only for minYear and maxYear
                let maxMonthForYear = year === maxYear ? maxMonth : 12;
                let minMonthForYear = year === minYear ? minMonth : 1;

                for (let month = maxMonthForYear; month >= minMonthForYear; month--) {
                    const paddedMonth = month.toString().padStart(2, '0');
                    dates.push(`${year}_${paddedMonth}`);
                }
            }

            return dates;
        }

        // Populate sidebar with date entries
        function populateDateSidebar() {
            const sidebar = document.getElementById('dateSidebar');
            const dates = generateDateList();
            sidebar.innerHTML = ''; // Clear existing entries
            dates.forEach(date => {
                const [year, month] = date.split('_');
                const entry = document.createElement('div');
                entry.className = 'date-entry';
                entry.textContent = date;
                entry.dataset.year = year;
                entry.dataset.month = month;
                entry.addEventListener('click', () => {
                    // Remove 'selected' class from all entries
                    sidebar.querySelectorAll('.date-entry').forEach(e => e.classList.remove('selected'));
                    // Add 'selected' class to clicked entry
                    entry.classList.add('selected');
                    // Update date input fields
                    const yearInput = document.getElementById('yearInput');
                    const monthInput = document.getElementById('monthInput');
                    yearInput.value = year;
                    monthInput.value = parseInt(month, 10); // Remove leading zero for display
                    // Load files for the selected date
                    loadFilesFromDataDir(year, month);
                });
                sidebar.appendChild(entry);
            });
        }

        function initializeSidebarHover() {
            const sidebar = document.getElementById('dateSidebar');
            const trigger = document.getElementById('sidebarTrigger');

            trigger.addEventListener('mouseenter', () => {
                sidebar.classList.add('visible');
            });

            sidebar.addEventListener('mouseenter', () => {
                sidebar.classList.add('visible');
            });

            sidebar.addEventListener('mouseleave', (e) => {
                if (!e.relatedTarget || (e.relatedTarget !== trigger && !trigger.contains(e.relatedTarget))) {
                    sidebar.classList.remove('visible');
                }
            });

            trigger.addEventListener('mouseleave', (e) => {
                if (!e.relatedTarget || (e.relatedTarget !== sidebar && !sidebar.contains(e.relatedTarget))) {
                    sidebar.classList.remove('visible');
                }
            });
        }

        function initializeDataSourceSelect() {
            const dataSourceSelect = document.getElementById('dataSourceSelect');
            dataSourceSelect.addEventListener('change', () => {
                // 刷新側邊欄的日期列表
                populateDateSidebar();

                // 清空圖表和相關 UI 元素
                datasetMap.clear();
                document.getElementById('fileListContainer').innerHTML = '';
                document.getElementById('chart-container').style.display = 'none';
                document.getElementById('metricsOutput').style.display = 'none';
                document.getElementById('metricsTableContainer').style.display = 'none';
                document.getElementById('showTableBtn').style.display = 'none';
                document.getElementById('resetColorsBtn').style.display = 'none';
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }

                // 更新輸入框的限制條件
                const yearInput = document.getElementById('yearInput');
                const monthInput = document.getElementById('monthInput');
                const selectedOption = dataSourceSelect.options[dataSourceSelect.selectedIndex];
                const minYear = parseInt(selectedOption.dataset.minYear);
                const maxYear = parseInt(selectedOption.dataset.maxYear);
                const minMonth = parseInt(selectedOption.dataset.minMonth);
                const maxMonth = parseInt(selectedOption.dataset.maxMonth);

                // 重置輸入框為空或預設值
                yearInput.value = '';
                monthInput.value = '';

                // 更新年份和月份的限制
                yearInput.min = minYear;
                yearInput.max = maxYear;
                monthInput.min = minMonth;
                monthInput.max = maxMonth;

                // 清空側邊欄的選中狀態
                const sidebar = document.getElementById('dateSidebar');
                sidebar.querySelectorAll('.date-entry').forEach(entry => {
                    entry.classList.remove('selected');
                });
            });
        }

        // Call populateDateSidebar when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            populateDateSidebar();
            initializeSidebarHover();
            initializeDateInputs();
            initializeDataSourceSelect();
        });

        // 初始化輸入框事件監聽器
        function initializeDateInputs() {
            const yearInput = document.getElementById('yearInput');
            const monthInput = document.getElementById('monthInput');
            const loadDateBtn = document.getElementById('loadDateBtn');
            const dataSourceSelect = document.getElementById('dataSourceSelect');

            function updateInputConstraints() {
                const selectedOption = dataSourceSelect.options[dataSourceSelect.selectedIndex];
                const minYear = parseInt(selectedOption.dataset.minYear);
                const maxYear = parseInt(selectedOption.dataset.maxYear);
                const minMonth = parseInt(selectedOption.dataset.minMonth);
                const maxMonth = parseInt(selectedOption.dataset.maxMonth);

                // Set year input constraints
                yearInput.min = minYear;
                yearInput.max = maxYear;
                yearInput.placeholder = `Year`;

                // Set month input constraints based on year
                const year = parseInt(yearInput.value) || maxYear;
                let minMonthForYear = year === minYear ? minMonth : 1;
                let maxMonthForYear = year === maxYear ? maxMonth : 12;

                monthInput.min = minMonthForYear;
                monthInput.max = maxMonthForYear;

                // Adjust month input if out of range
                const currentMonth = parseInt(monthInput.value);
                if (currentMonth < minMonthForYear) {
                    monthInput.value = minMonthForYear;
                }
                else if (currentMonth > maxMonthForYear) {
                    monthInput.value = maxMonthForYear;
                }
            }

            // Initialize constraints on page load
            updateInputConstraints();

            // Update constraints when dataset or year changes
            dataSourceSelect.addEventListener('change', updateInputConstraints);
            yearInput.addEventListener('input', updateInputConstraints);

            // 點擊「載入」按鈕時觸發
            loadDateBtn.addEventListener('click', () => {
                let year = yearInput.value.trim();
                let month = monthInput.value.trim().padStart(2, '0');

                // 如果沒有輸入，預設為最大年份和最大月份
                if (!year && (!month || month === '00')) {
                    const selectedOption = dataSourceSelect.options[dataSourceSelect.selectedIndex];
                    year = selectedOption.dataset.maxYear;
                    const maxMonth = selectedOption.dataset.maxMonth;
                    month = maxMonth.padStart(2, '0');
                    yearInput.value = year;
                    monthInput.value = parseInt(maxMonth);
                }

                if (validateDate(year, month)) {
                    loadFilesFromDataDir(year, month);
                    updateSidebarSelection(year, month);
                } else {
                    const selectedOption = dataSourceSelect.options[dataSourceSelect.selectedIndex];
                    const minYear = selectedOption.dataset.minYear;
                    const maxYear = selectedOption.dataset.maxYear;
                    const minMonth = selectedOption.dataset.minMonth;
                    const maxMonth = selectedOption.dataset.maxMonth;
                    alert(`區間範圍 ${minYear}/${minMonth.padStart(2, '0')} ~ ${maxYear}/${maxMonth.padStart(2, '0')}`);
                }
            });

            // 按下 Enter 鍵時觸發
            [yearInput, monthInput].forEach(input => {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        let year = yearInput.value.trim();
                        let month = monthInput.value.trim().padStart(2, '0');

                        // 如果沒有輸入，預設為最大年份和最大月份
                        if (!year && (!month || month === '00')) {
                            const selectedOption = dataSourceSelect.options[dataSourceSelect.selectedIndex];
                            year = selectedOption.dataset.maxYear;
                            const maxMonth = selectedOption.dataset.maxMonth;
                            month = maxMonth.padStart(2, '0');
                            yearInput.value = year;
                            monthInput.value = parseInt(maxMonth);
                        }

                        if (validateDate(year, month)) {
                            loadFilesFromDataDir(year, month);
                            updateSidebarSelection(year, month);
                        } else {
                            const selectedOption = dataSourceSelect.options[dataSourceSelect.selectedIndex];
                            const minYear = selectedOption.dataset.minYear;
                            const maxYear = selectedOption.dataset.maxYear;
                            const minMonth = selectedOption.dataset.minMonth;
                            const maxMonth = selectedOption.dataset.maxMonth;
                            alert(`區間範圍 ${minYear}/${minMonth.padStart(2, '0')} ~ ${maxYear}/${maxMonth.padStart(2, '0')}`);
                        }
                    }
                });
            });
        }

        // 驗證年份和月份
        function validateDate(year, month) {
            const y = parseInt(year);
            const m = parseInt(month);
            if (isNaN(y) || isNaN(m)) return false;

            const dataSourceSelect = document.getElementById('dataSourceSelect');
            const selectedOption = dataSourceSelect.options[dataSourceSelect.selectedIndex];
            const minYear = parseInt(selectedOption.dataset.minYear);
            const maxYear = parseInt(selectedOption.dataset.maxYear);
            const minMonth = parseInt(selectedOption.dataset.minMonth);

            if (y < minYear || y > maxYear) return false;
            if (m < 1 || m > 12) return false;

            // Check minimum month for the starting year
            if (y === minYear && m < minMonth) return false;

            // Check maximum month for the year
            const maxMonthAttr = selectedOption.dataset[`maxMonth${y}`];
            const maxMonth = maxMonthAttr ? parseInt(maxMonthAttr) : 12;
            if (m > maxMonth) return false;

            return true;
        }

        // 更新側邊欄選中狀態
        function updateSidebarSelection(year, month) {
            const sidebar = document.getElementById('dateSidebar');
            sidebar.querySelectorAll('.date-entry').forEach(entry => {
                entry.classList.remove('selected');
                if (entry.dataset.year === year && entry.dataset.month === month) {
                    entry.classList.add('selected');
                }
            });
        }

        // Modified loadFilesFromDataDir to accept year and month parameters
        async function loadFilesFromDataDir(year, month) {
            if (!year || !month) {
                alert('請選擇一個日期');
                return;
            }
            const dataSource = document.getElementById('dataSourceSelect').value;
            const paddedMonth = month.padStart(2, '0');
            const pattern = `${year}_${paddedMonth}`;
            let csvFiles = [];
            if (dataSource === 'EPM_H-MoQTS') {
                csvFiles = [
                    `H-MoQTS/MoQTS/UA_${year}_${paddedMonth}%28${year}%20Q1%29_60%23_front.csv`,
                    `H-MoQTS/SMS-EMOA/NIKKEI30%26DJIA30_2015-2024_SMS-EMOA_3_999_100_10M_M2M_Pareto_Front_${year}_${paddedMonth}%28${year}%20Q1%29.csv`,
                    `H-MoQTS/MOEAD/NIKKEI30&DJIA30_2015-2024_MOEAD_3_999_100_10_10_10M_M2M_Pareto_Front_${year}_${paddedMonth}%28${year}%20Q1%29.csv`,
                    `H-MoQTS/NSGA-II/NSGA_train_${year}_${paddedMonth}%28${year}%20Q1%29.csv`
                ];
            } else if (dataSource === 'WPM_MoQA') {
                csvFiles = [
                    `WPM-MoQA/MoQA/${year}_${paddedMonth}_0.025_Result.csv`,
                    `WPM-MoQA/SMS-EMOA/SMS-EMOA_M2M_${year}_${paddedMonth}%28${year}%20Q1%29.csv`,
                    `WPM-MoQA/MOEAD/MOEAD_M2M_${year}_${paddedMonth}%28${year}%20Q1%29.csv`,
                    `WPM-MoQA/NSGA-II/NSGA_train_${year}_${paddedMonth}%28${year}%20Q1%29.csv`
                ];
            }

            try {
                datasetMap.clear();
                document.getElementById('fileListContainer').innerHTML = '';

                for (const filePath of csvFiles) {
                    //alert(`${filePath}`)
                    try {
                        const fileResponse = await fetch(`https://pingi0131.github.io/compare_fronts/data/${filePath}`);
                        if (!fileResponse.ok) {
                            console.error(`無法讀取檔案 ${filePath}: ${fileResponse.status}`);
                            continue;
                        }

                        const text = await fileResponse.text();
                        const lines = text.split(/\r?\n/);
                        if (lines.length === 0) continue;

                        const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                        const riskIndex = headers.findIndex(h => h.includes('risk'));
                        const profitIndex = headers.findIndex(h => h.includes('profit') || h.includes('return'));

                        if (riskIndex === -1 || profitIndex === -1) continue;

                        const parsedSet = new Set();
                        const parsed = [];

                        for (let i = 1; i < lines.length; i++) {
                            const line = lines[i].trim();
                            if (!line) continue;

                            const cols = line.split(',');
                            const x = parseFloat(cols[riskIndex]);
                            const y = parseFloat(cols[profitIndex]);
                            const key = `${x},${y}`;

                            if (!isNaN(x) && !isNaN(y) && x > 0 && y > 0 && !parsedSet.has(key)) {
                                parsedSet.add(key);
                                parsed.push({ x, y });
                            }
                        }

                        if (parsed.length > 0) {
                            const fileName = filePath.split('/').pop();
                            const folder = filePath.split('/')[1].replace('%28M2M%29', '(M2M)'); // Use second-level folder
                            const displayFolder = folder === 'MOEAD' ? 'MOEA/D' : folder;
                            const color = (folder === 'MoQTS' || folder === 'MoQA') ? '#FF0000' : defaultColors[datasetMap.size - 1 % defaultColors.length] || '#000000'; // Adjust index
                            const simplifiedFileName = `${displayFolder}_${year}_${paddedMonth}_front.csv`;
                            datasetMap.set(fileName, {
                                name: displayFolder,
                                data: parsed.sort((a, b) => a.x - b.x),
                                color,
                                simplifiedName: simplifiedFileName
                            });
                            addFileEntryUI(fileName, color);
                        }
                    } catch (fileError) {
                        console.error(`處理檔案 ${filePath} 時發生錯誤:`, fileError);
                    }
                }

                if (datasetMap.size > 0) {
                    drawChart(); // 繪製圖表
                    document.getElementById('resetColorsBtn').style.display = 'inline-block';
                    calculateMetrics();
                } else {
                    alert(`沒有成功載入任何符合 "${pattern}" 的有效 CSV 檔案`);
                    // Clear and hide UI elements
                    datasetMap.clear();
                    document.getElementById('fileListContainer').innerHTML = '';
                    document.getElementById('chart-container').style.display = 'none';
                    document.getElementById('metricsOutput').style.display = 'none';
                    document.getElementById('metricsTableContainer').style.display = 'none';
                    document.getElementById('showTableBtn').style.display = 'none';
                    document.getElementById('resetColorsBtn').style.display = 'none';
                    if (chartInstance) {
                        chartInstance.destroy();
                        chartInstance = null;
                    }
                }
            } catch (error) {
                console.error('載入檔案時發生錯誤:', error);
                alert(`載入檔案時發生錯誤: ${error.message}`);
            }
        }

        const minRiskInput = document.getElementById('minRisk');
        const maxRiskInput = document.getElementById('maxRisk');
        const minProfitInput = document.getElementById('minProfit');
        const maxProfitInput = document.getElementById('maxProfit');
        const defaultRanges = {
            minRisk: undefined,
            maxRisk: undefined,
            minProfit: undefined,
            maxProfit: undefined
        };
        [minRiskInput, maxRiskInput, minProfitInput, maxProfitInput].forEach(input => {
            input.addEventListener('blur', () => {
                if (datasetMap.size > 0) {
                    drawChart();
                    calculateMetrics();
                    // If table is visible, regenerate it
                    if (document.getElementById('metricsTableContainer').style.display === 'block') {
                        generateMetricsTable();
                    }
                }
            });
            input.addEventListener('keypress', e => {
                if (e.key === 'Enter' && datasetMap.size > 0) {
                    drawChart();
                    calculateMetrics();
                    // If table is visible, regenerate it
                    if (document.getElementById('metricsTableContainer').style.display === 'block') {
                        generateMetricsTable();
                    }
                }
            });
        });

        function resetField(fieldId) {
            document.getElementById(fieldId).value = defaultRanges[fieldId] ?? '';
            if (datasetMap.size > 0) {
                drawChart();
                calculateMetrics();
                if (document.getElementById('metricsTableContainer').style.display === 'block') {
                    generateMetricsTable();
                }
            }
        }

        function resetAllRanges() {
            for (const key in defaultRanges) {
                document.getElementById(key).value = defaultRanges[key] ?? '';
            }
            if (datasetMap.size > 0) {
                drawChart();
                calculateMetrics();
                if (document.getElementById('metricsTableContainer').style.display === 'block') {
                    generateMetricsTable();
                }
            }
        }

        function resetColors() {
            const entries = Array.from(datasetMap.entries());
            entries.forEach(([fileName, data], index) => {
                const newColor = (data.name === 'MoQTS' || data.name === 'MoQA') ? '#FF0000' : defaultColors[index - 1 % defaultColors.length] || '#000000';
                data.color = newColor;
                data.opacity = 1;
                const entryDiv = document.getElementById(`entry-${CSS.escape(fileName)}`);
                if (entryDiv) {
                    const colorPreview = entryDiv.querySelector('.color-preview-box-list');
                    if (colorPreview) {
                        colorPreview.style.backgroundColor = newColor;
                        colorPreview.style.opacity = 1;
                    }
                    const modal = entryDiv.querySelector('.color-picker-modal');
                    if (modal) {
                        const hexInput = modal.querySelector('.hex-input');
                        const rgbSliders = modal.querySelectorAll('.rgb-slider');
                        const rgbNumbers = modal.querySelectorAll('.rgb-number');
                        const rgbPreviewBoxes = modal.querySelectorAll('.rgb-preview-box');
                        const opacitySlider = modal.querySelector('.opacity-slider');
                        const opacityNumber = modal.querySelector('.opacity-number');
                        const livePreview = modal.querySelector('.live-preview');
                        const nativeColorInput = modal.querySelector('.native-color-input');

                        const r = parseInt(newColor.slice(1, 3), 16);
                        const g = parseInt(newColor.slice(3, 5), 16);
                        const b = parseInt(newColor.slice(5, 7), 16);
                        const a = 1;

                        hexInput.value = newColor;
                        rgbSliders[0].value = r;
                        rgbSliders[1].value = g;
                        rgbSliders[2].value = b;
                        rgbNumbers[0].value = r;
                        rgbNumbers[1].value = g;
                        rgbNumbers[2].value = b;
                        rgbPreviewBoxes[0].style.backgroundColor = `rgb(${r}, 0, 0)`;
                        rgbPreviewBoxes[1].style.backgroundColor = `rgb(0, ${g}, 0)`;
                        rgbPreviewBoxes[2].style.backgroundColor = `rgb(0, 0, ${b})`;
                        opacitySlider.value = a;
                        opacityNumber.value = Math.round(a * 100); // Convert to percentage
                        livePreview.style.backgroundColor = newColor;
                        livePreview.style.opacity = a;
                        nativeColorInput.value = newColor;
                    }
                }
            });
            if (datasetMap.size > 0) {
                drawChart();
            }
            document.getElementById('resetColorsBtn').style.display = datasetMap.size > 0 ? 'inline-block' : 'none';
        }

        function normalize(data) {
            const allRisks = Object.values(data).flatMap(d => d.risk);
            const allProfits = Object.values(data).flatMap(d => d.profit);
            const minRisk = Math.min(...allRisks);
            const maxRisk = Math.max(...allRisks) * 1.01;
            const minProfit = Math.min(...allProfits) * 0.99;
            const maxProfit = Math.max(...allProfits);
            console.log(`Normalization bounds: min risk:${minRisk}, max risk:${maxRisk}, min profit:${minProfit}, max profit:${maxProfit}`);
            const result = {};
            for (const name in data) {
                const normalizedRisk = [];
                const normalizedProfit = [];
                for (let i = 0; i < data[name].risk.length; i++) {
                    const risk = data[name].risk[i];
                    const profit = data[name].profit[i];
                    const newRisk = (risk - minRisk) / (maxRisk - minRisk);
                    const newProfit = (profit - minProfit) / (maxProfit - minProfit);
                    normalizedRisk.push(newRisk);
                    normalizedProfit.push(newProfit);
                }
                result[name] = {
                    risk: normalizedRisk,
                    profit: normalizedProfit
                };
            }
            return result;
        }

        function combineNonDominatedSets(dataSets) {
            const combinedRisk = [];
            const combinedProfit = [];
            for (const [_, dataSet] of dataSets.entries()) {
                for (let i = 0; i < dataSet.data.length; i++) {
                    const risk = dataSet.data[i].x;
                    const profit = dataSet.data[i].y;
                    let addNew = true;
                    let j = 0;
                    while (j < combinedRisk.length) {
                        if (profit <= combinedProfit[j] && risk >= combinedRisk[j]) {
                            addNew = false;
                            break;
                        }
                        if (profit > combinedProfit[j] && risk < combinedRisk[j]) {
                            combinedRisk.splice(j, 1);
                            combinedProfit.splice(j, 1);
                        } else {
                            j++;
                        }
                    }
                    if (addNew) {
                        combinedRisk.push(risk);
                        combinedProfit.push(profit);
                    }
                }
            }
            const sortedPairs = combinedRisk.map((risk, i) => [risk, combinedProfit[i]])
                .sort((a, b) => a[0] - b[0]);
            const sortedRisk = sortedPairs.map(pair => pair[0]);
            const sortedProfit = sortedPairs.map(pair => pair[1]);
            return {
                risk: sortedRisk,
                profit: sortedProfit
            };
        }

        function calcGD(normalized, frontKey) {
            const result = {};
            const normalizedFront = {
                risk: normalized[frontKey].risk,
                profit: normalized[frontKey].profit
            };
            for (const name in normalized) {
                const data = normalized[name];
                let sumMin = 0.0;
                for (let i = 0; i < data.risk.length; i++) {
                    const risk = data.risk[i];
                    const profit = data.profit[i];
                    let minDis = Infinity;
                    for (let j = 0; j < normalizedFront.risk.length; j++) {
                        const pRisk = normalizedFront.risk[j];
                        const pProfit = normalizedFront.profit[j];
                        const distance = Math.sqrt(Math.pow(pRisk - risk, 2) + Math.pow(pProfit - profit, 2));
                        if (distance < minDis) {
                            minDis = distance;
                        }
                    }
                    sumMin += Math.pow(minDis, 2);
                }
                result[name] = Math.sqrt(sumMin) / data.risk.length;
            }
            return result;
        }

        function calcIGD(normalized, frontKey) {
            const result = {};
            const normalizedFront = {
                risk: normalized[frontKey].risk,
                profit: normalized[frontKey].profit
            };
            for (const name in normalized) {
                const data = normalized[name];
                let sumMin = 0.0;
                for (let j = 0; j < normalizedFront.risk.length; j++) {
                    const pRisk = normalizedFront.risk[j];
                    const pProfit = normalizedFront.profit[j];
                    let minDis = Infinity;
                    for (let i = 0; i < data.risk.length; i++) {
                        const risk = data.risk[i];
                        const profit = data.profit[i];
                        const distance = Math.sqrt(Math.pow(pRisk - risk, 2) + Math.pow(pProfit - profit, 2));
                        if (distance < minDis) {
                            minDis = distance;
                        }
                    }
                    sumMin += Math.pow(minDis, 2);
                }
                result[name] = Math.sqrt(sumMin) / normalizedFront.risk.length;
            }
            return result;
        }

        function calcHV(normalized) {
            const result = {};
            const refPointX = 1.0;
            const refPointY = 0.0;
            for (const name in normalized) {
                let hv = 0;
                const r = normalized[name].risk;
                const p = normalized[name].profit;
                const sortedIndices = Array.from({ length: r.length }, (_, i) => i)
                    .sort((a, b) => r[a] - r[b]);
                let prevProfit = refPointY;
                for (const idx of sortedIndices) {
                    const risk = r[idx];
                    const profit = p[idx];
                    if (profit > prevProfit) {
                        hv += Math.abs((refPointX - risk) * (profit - prevProfit));
                        prevProfit = profit;
                    }
                }
                result[name] = hv;
            }
            return result;
        }

        function calculateHitRate(normalized) {
            const hitRate = {};
            const hitCounts = {};
            const coRisk = normalized["Combined Front"].risk;
            const numCo = coRisk.length;
            for (const name in normalized) {
                let time = 0;
                const otherRisk = normalized[name].risk;
                for (const r of otherRisk) {
                    if (coRisk.some(coR => Math.abs(coR - r) < 1e-10)) {
                        time += 1;
                    }
                }
                hitRate[name] = numCo > 0 ? (time / numCo) * 100 : 0;
                hitCounts[name] = {
                    hits: time,
                    total: numCo
                };
            }
            return {
                percentages: hitRate,
                counts: hitCounts
            };
        }

        function checkAllNames() {
            for (const [fileName, data] of datasetMap) {
                if (!data.name.trim()) {
                    return false;
                }
            }
            return true;
        }

        function calculateMetrics() {
            const showTableBtn = document.getElementById('showTableBtn');
            if (datasetMap.size < 2) {
                document.getElementById('metricsOutput').style.display = 'none';
                document.getElementById('metricsTableContainer').style.display = 'none';
                showTableBtn.style.display = 'none';
                return;
            }

            // Get range inputs
            const minRisk = parseFloat(minRiskInput.value);
            const maxRisk = parseFloat(maxRiskInput.value);
            const minProfit = parseFloat(minProfitInput.value);
            const maxProfit = parseFloat(maxProfitInput.value);

            // Filter data based on ranges
            const filteredMap = filterDataByRange(datasetMap, minRisk, maxRisk, minProfit, maxProfit);

            if (filteredMap.size < 2) {
                document.getElementById('metricsOutput').textContent = '設定的風險報酬範圍沒有解，確認放大區域數值範圍';
                document.getElementById('metricsOutput').style.display = 'block';
                document.getElementById('metricsTableContainer').style.display = 'none';
                showTableBtn.style.display = 'none';
                return;
            }

            const rawData = {};
            filteredMap.forEach((value, key) => {
                rawData[key] = {
                    risk: value.data.map(d => d.x),
                    profit: value.data.map(d => d.y)
                };
            });

            const combinedFrontData = combineNonDominatedSets(filteredMap);
            rawData["Combined Front"] = {
                risk: combinedFrontData.risk,
                profit: combinedFrontData.profit
            };

            const normalized = normalize(rawData);

            try {
                const HV = calcHV(normalized);
                const GD = calcGD(normalized, "Combined Front");
                const IGD = calcIGD(normalized, "Combined Front");
                const hitRateResult = calculateHitRate(normalized);
                const hitRate = hitRateResult.percentages;

                let output = '';
                for (const name of Object.keys(normalized)) {
                    if (name === "Combined Front") {
                        continue;
                    }
                    const hv = HV[name].toFixed(4);
                    const gd = formatScientific(GD[name], 2);
                    const igd = formatScientific(IGD[name], 2);
                    const hv_value = HV[name].toFixed(20);
                    const gd_value = GD[name].toFixed(20);
                    const igd_value = IGD[name].toFixed(20);
                    const displayName = filteredMap.get(name)?.simplifiedName || name;
                    output += `${displayName}\nHV:  ${hv} (${hv_value})\nGD:  ${gd} (${gd_value})\nIGD: ${igd} (${igd_value})\n\n`;
                }

                const panel = document.getElementById('metricsOutput');
                panel.textContent = output.trim();
                panel.style.display = 'block';
                showTableBtn.style.display = 'inline-block';
                combinedFront = combinedFrontData;
                document.getElementById('metricsTableContainer').style.display = 'none';
            } catch (e) {
                console.error("Error calculating metrics:", e);
                document.getElementById('metricsOutput').textContent = "Error calculating metrics: " + e.message;
                document.getElementById('metricsOutput').style.display = 'block';
                showTableBtn.style.display = 'none';
                document.getElementById('metricsTableContainer').style.display = 'none';
            }
        }

        function generateMetricsTable() {
            if (!datasetMap || datasetMap.size < 2) {
                alert('請至少上傳兩個前緣檔案以顯示指標表格！');
                return;
            }
            if (!checkAllNames()) {
                alert('請先為所有前緣輸入名稱！');
                return;
            }

            // Get range inputs
            const minRisk = parseFloat(minRiskInput.value);
            const maxRisk = parseFloat(maxRiskInput.value);
            const minProfit = parseFloat(minProfitInput.value);
            const maxProfit = parseFloat(maxProfitInput.value);

            // Filter data based on ranges
            const filteredMap = filterDataByRange(datasetMap, minRisk, maxRisk, minProfit, maxProfit);

            if (filteredMap.size < 2) {
                alert('設定的風險報酬範圍沒有解，確認放大區域數值範圍');
                return;
            }

            const rawData = {};
            filteredMap.forEach((value, key) => {
                rawData[key] = {
                    risk: value.data.map(d => d.x),
                    profit: value.data.map(d => d.y)
                };
            });

            const combinedFrontData = combineNonDominatedSets(filteredMap);
            rawData["Combined Front"] = {
                risk: combinedFrontData.risk,
                profit: combinedFrontData.profit
            };

            const normalized = normalize(rawData);
            const HV = calcHV(normalized);
            const GD = calcGD(normalized, "Combined Front");
            const IGD = calcIGD(normalized, "Combined Front");
            const hitRateResult = calculateHitRate(normalized);
            const hitRate = hitRateResult.percentages;
            const hitCounts = hitRateResult.counts;

            const combinedHV = HV["Combined Front"];
            const HVR = {};
            for (const name in HV) {
                HVR[name] = combinedHV > 0 ? (HV[name] / combinedHV) * 100 : 0;
            }

            const tableBody = document.getElementById('metricsTable').querySelector('tbody');
            tableBody.innerHTML = '';

            const metricsData = [];
            let combinedFrontMetrics = null;
            for (const name in normalized) {
                const pointCount = name === "Combined Front" ?
                    combinedFrontData.risk.length :
                    filteredMap.get(name)?.data.length || 0;
                const data = {
                    fileName: name,
                    customName: name === "Combined Front" ? "Combined" : filteredMap.get(name)?.name || name.replace('MOEAD', 'MOEA/D'),
                    points: pointCount,
                    hv: HV[name],
                    gd: GD[name],
                    igd: IGD[name],
                    hvRate: HVR[name],
                    hitRate: hitRate[name]
                };
                if (name === "Combined Front") {
                    combinedFrontMetrics = data;
                } else {
                    metricsData.push(data);
                }
            }

            const maxNDS = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.points)) : 0;
            const maxHV = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.hv)) : 0;
            const minGD = metricsData.length > 0 ? Math.min(...metricsData.map(d => d.gd)) : Infinity;
            const minIGD = metricsData.length > 0 ? Math.min(...metricsData.map(d => d.igd)) : Infinity;
            const maxHVRate = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.hvRate)) : 0;
            const maxHitRate = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.hitRate)) : 0;

            metricsData.forEach(data => {
                const hitCount = hitCounts[data.fileName] || { hits: 0, total: 0 };
                const row = document.createElement('tr');
                row.innerHTML = `
            <td>${data.customName}</td>
            <td class="${data.points === maxNDS ? 'best' : ''}">${data.points}</td>
            <td class="${data.hv === maxHV ? 'best' : ''}">${data.hv.toFixed(4)}</td>
            <td class="${data.hvRate === maxHVRate ? 'best' : ''}">${data.hvRate.toFixed(2)}%</td>
            <td class="${data.hitRate === maxHitRate ? 'best' : ''}">
                ${data.hitRate.toFixed(2)}%
                <span style="font-size: 0.7em; vertical-align: middle;">
                    \\( \\frac{${hitCount.hits}}{${hitCount.total}} \\)
                </span>
            </td>
            <td class="${data.gd === minGD ? 'best' : ''}">${formatScientific(data.gd, 2)}</td>
            <td class="${data.igd === minIGD ? 'best' : ''}">${formatScientific(data.igd, 2)}</td>
        `;
                tableBody.appendChild(row);
            });

            if (combinedFrontMetrics) {
                const hitCount = hitCounts[combinedFrontMetrics.fileName] || { hits: 0, total: 0 };
                const row = document.createElement('tr');
                row.className = 'combined-front';
                row.innerHTML = `
            <td>${combinedFrontMetrics.customName}</td>
            <td>${combinedFrontMetrics.points}</td>
            <td>${combinedFrontMetrics.hv.toFixed(4)}</td>
            <td>${combinedFrontMetrics.hvRate.toFixed(2)}%</td>
            <td>
                ${combinedFrontMetrics.hitRate.toFixed(2)}%
                <span style="font-size: 0.7em; vertical-align: middle;">
                    \\( \\frac{${hitCount.hits}}{${hitCount.total}} \\)
                </span>
            </td>
            <td>${formatScientific(combinedFrontMetrics.gd, 2)}</td>
            <td>${formatScientific(combinedFrontMetrics.igd, 2)}</td>
        `;
                tableBody.appendChild(row);
            }

            document.getElementById('metricsTableContainer').style.display = 'block';
            if (window.MathJax) {
                MathJax.typeset();
            }
        }

        document.getElementById('showTableBtn').addEventListener('click', generateMetricsTable);

        function formatScientific(number, digits) {
            const str = number.toExponential(digits);
            const parts = str.split('e');
            const coefficient = parts[0];
            const exponentNum = parseInt(parts[1], 10);
            const sign = exponentNum >= 0 ? '+' : '-';
            const exponent = sign + Math.abs(exponentNum).toString().padStart(2, '0');
            return `${coefficient}E${exponent}`;
        }

        let modalCounter = 0;

        function addFileEntryUI(fileName, defaultColor) {
            const container = document.getElementById('fileListContainer');
            const entry = document.createElement('div');
            entry.className = 'file-entry';
            entry.id = `entry-${CSS.escape(fileName)}`;

            const colorPreview = document.createElement('div');
            colorPreview.className = 'color-preview-box-list';
            colorPreview.style.backgroundColor = defaultColor;
            colorPreview.style.opacity = datasetMap.get(fileName).opacity || 1;
            colorPreview.title = '點擊選擇顏色';

            const modalId = `color-picker-${modalCounter++}`;
            const modal = document.createElement('div');
            modal.className = 'color-picker-modal';
            modal.style.display = 'none';
            modal.innerHTML = `
        <div class="color-picker-tabs">
            <button data-tab="common" class="active">常用顏色</button>
            <button data-tab="hexrgb">HEX & RGB</button>
            <button data-tab="native">原生選擇器</button>
        </div>
        <div class="color-picker-content active" id="${modalId}-common">
            <div class="common-colors">
                ${[
                    ['#C00000', '#FF0000', '#FFC000', '#FFFF00', '#92D050', '#00B050', '#5B9BD5', '#4472C4', '#002060', '#7030A0'],
                    ['#FFE6E6', '#FF6666', '#FFF2CC', '#FFFF99', '#CCFF99', '#99FFCC', '#B3CDEB', '#A3BFFA', '#99A3CC', '#C2A3CC'],
                    ['#FFCCCC', '#FF3333', '#FFE699', '#FFFF66', '#B3E67A', '#66FF99', '#99BCE2', '#8AA7FA', '#667AB3', '#AD80BF'],
                    ['#FF9999', '#CC0000', '#FFD966', '#CCCC00', '#8CCB5E', '#33CC66', '#7FAAD8', '#7088F5', '#335099', '#985EAD'],
                    ['#B30000', '#990000', '#BF9000', '#999900', '#6B9B44', '#26994D', '#4C739B', '#3957A6', '#263C66', '#5E3A73']
                ].map(column => column.map(color => `<div class="color-swatch" style="background-color: ${color};" data-color="${color}"></div>`).join('')).join('')}
            </div>
        </div>
        <div class="color-picker-content" id="${modalId}-hexrgb">
            <div class="hexrgb-inputs">
                <label><span>紅 :</span>
                    <div class="rgb-preview-box" style="background-color: rgb(${parseInt(defaultColor.slice(1, 3), 16)}, 0, 0);"></div>
                    <input type="range" min="0" max="255" value="${parseInt(defaultColor.slice(1, 3), 16)}" class="rgb-slider">
                    <input type="number" min="0" max="255" value="${parseInt(defaultColor.slice(1, 3), 16)}" class="rgb-number">
                </label>
                <label><span>綠 :</span>
                    <div class="rgb-preview-box" style="background-color: rgb(0, ${parseInt(defaultColor.slice(3, 5), 16)}, 0);"></div>
                    <input type="range" min="0" max="255" value="${parseInt(defaultColor.slice(3, 5), 16)}" class="rgb-slider">
                    <input type="number" min="0" max="255" value="${parseInt(defaultColor.slice(3, 5), 16)}" class="rgb-number">
                </label>
                <label><span>藍 :</span>
                    <div class="rgb-preview-box" style="background-color: rgb(0, 0, ${parseInt(defaultColor.slice(5, 7), 16)});"></div>
                    <input type="range" min="0" max="255" value="${parseInt(defaultColor.slice(5, 7), 16)}" class="rgb-slider">
                    <input type="number" min="0" max="255" value="${parseInt(defaultColor.slice(5, 7), 16)}" class="rgb-number">
                </label>
                <label><span>不透明度 :</span>
                    <input type="range" min="0" max="1" step="0.01" value="${datasetMap.get(fileName).opacity || 1}" class="opacity-slider">
                    <input type="number" min="0" max="100" step="1" value="${Math.round((datasetMap.get(fileName).opacity || 1) * 100)}" class="opacity-number">%
                </label>
                <div style="display: flex; align-items: center; gap: 8px; justify-content: flex-end;">
                    <span>十六進位表示 :</span>
                    <div class="color-preview-box live-preview" style="background-color: ${defaultColor}; opacity: ${datasetMap.get(fileName).opacity || 1};"></div>
                    <input type="text" class="hex-input" placeholder="#FFFFFF" value="${defaultColor}" style="width: 100px;">
                    <button class="confirm-btn">更新</button>
                </div>
            </div>
        </div>
        <div class="color-picker-content" id="${modalId}-native">
            <input type="color" class="native-color-input" value="${defaultColor}" style="width: 115px; height: 40px; border: none; outline: none; cursor: pointer; background: transparent; padding: 0;">
        </div>
    `;

            entry.appendChild(modal);

            const tabs = modal.querySelectorAll('.color-picker-tabs button');
            const contents = modal.querySelectorAll('.color-picker-content');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    contents.forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    const content = modal.querySelector(`#${modalId}-${tab.dataset.tab}`);
                    if (content) {
                        content.classList.add('active');
                    } else {
                        console.error(`Content element #${modalId}-${tab.dataset.tab} not found`);
                    }
                });
            });

            const colorSwatches = modal.querySelectorAll('.color-swatch');
            colorSwatches.forEach(swatch => {
                swatch.addEventListener('click', () => {
                    const color = swatch.getAttribute('data-color');
                    const opacity = parseFloat(modal.querySelector(`#${modalId}-hexrgb .opacity-number`).value) / 100 || 1;
                    updateColor(color, opacity);
                });
            });

            const updateColor = (hex, opacity = 1) => {
                datasetMap.get(fileName).color = hex;
                datasetMap.get(fileName).opacity = opacity;
                colorPreview.style.backgroundColor = hex;
                colorPreview.style.opacity = opacity;

                const hexInput = modal.querySelector(`#${modalId}-hexrgb .hex-input`);
                const rgbSliders = modal.querySelectorAll(`#${modalId}-hexrgb .rgb-slider`);
                const rgbNumbers = modal.querySelectorAll(`#${modalId}-hexrgb .rgb-number`);
                const rgbPreviewBoxes = modal.querySelectorAll(`#${modalId}-hexrgb .rgb-preview-box`);
                const opacitySlider = modal.querySelector(`#${modalId}-hexrgb .opacity-slider`);
                const opacityNumber = modal.querySelector(`#${modalId}-hexrgb .opacity-number`);
                const livePreview = modal.querySelector(`#${modalId}-hexrgb .live-preview`);

                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);

                hexInput.value = hex;
                rgbSliders[0].value = r;
                rgbSliders[1].value = g;
                rgbSliders[2].value = b;
                rgbNumbers[0].value = r;
                rgbNumbers[1].value = g;
                rgbNumbers[2].value = b;
                rgbPreviewBoxes[0].style.backgroundColor = `rgb(${r}, 0, 0)`;
                rgbPreviewBoxes[1].style.backgroundColor = `rgb(0, ${g}, 0)`;
                rgbPreviewBoxes[2].style.backgroundColor = `rgb(0, 0, ${b})`;
                opacitySlider.value = opacity;
                opacityNumber.value = Math.round(opacity * 100);
                livePreview.style.backgroundColor = hex;
                livePreview.style.opacity = opacity;

                const nativeColorInput = modal.querySelector(`#${modalId}-native .native-color-input`);
                nativeColorInput.value = hex;

                drawChart();
                modal.style.display = 'none';
            };

            const nativeColorInput = modal.querySelector(`#${modalId}-native .native-color-input`);
            const updateFromNativeInput = () => {
                const hex = nativeColorInput.value;
                const opacity = parseFloat(modal.querySelector(`#${modalId}-hexrgb .opacity-number`).value) / 100 || 1;
                updateColor(hex, opacity);
            };

            nativeColorInput.addEventListener('input', updateFromNativeInput);
            nativeColorInput.addEventListener('change', updateFromNativeInput);

            const hexInput = modal.querySelector(`#${modalId}-hexrgb .hex-input`);
            const rgbSliders = modal.querySelectorAll(`#${modalId}-hexrgb .rgb-slider`);
            const rgbNumbers = modal.querySelectorAll(`#${modalId}-hexrgb .rgb-number`);
            const opacitySlider = modal.querySelector(`#${modalId}-hexrgb .opacity-slider`);
            const opacityNumber = modal.querySelector(`#${modalId}-hexrgb .opacity-number`);
            const confirmBtn = modal.querySelector(`#${modalId}-hexrgb .confirm-btn`);
            const livePreview = modal.querySelector(`#${modalId}-hexrgb .live-preview`);

            const updatePreview = () => {
                const r = parseInt(rgbNumbers[0].value) || 0;
                const g = parseInt(rgbNumbers[1].value) || 0;
                const b = parseInt(rgbNumbers[2].value) || 0;
                const a = parseFloat(opacityNumber.value) / 100 || 0; // Use 0 if invalid
                if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255 && a >= 0 && a <= 1) {
                    const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    livePreview.style.backgroundColor = hex;
                    livePreview.style.opacity = a;
                    hexInput.value = hex;
                }
            };

            const updateFromHex = () => {
                const value = hexInput.value.trim();
                if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
                    const r = parseInt(value.slice(1, 3), 16);
                    const g = parseInt(value.slice(3, 5), 16);
                    const b = parseInt(value.slice(5, 7), 16);
                    const a = parseFloat(opacityNumber.value) / 100 || 0;
                    rgbPreviewBoxes[0].style.backgroundColor = `rgb(${r}, 0, 0)`;
                    rgbPreviewBoxes[1].style.backgroundColor = `rgb(0, ${g}, 0)`;
                    rgbPreviewBoxes[2].style.backgroundColor = `rgb(0, 0, ${b})`;
                    livePreview.style.backgroundColor = value;
                    livePreview.style.opacity = a;
                    updateColor(value, a);
                }
            };

            const updateFromRGB = () => {
                const r = parseInt(rgbNumbers[0].value) || 0;
                const g = parseInt(rgbNumbers[1].value) || 0;
                const b = parseInt(rgbNumbers[2].value) || 0;
                const a = parseFloat(opacityNumber.value) / 100 || 0;
                if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255 && a >= 0 && a <= 1) {
                    const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    rgbPreviewBoxes[0].style.backgroundColor = `rgb(${r}, 0, 0)`;
                    rgbPreviewBoxes[1].style.backgroundColor = `rgb(0, ${g}, 0)`;
                    rgbPreviewBoxes[2].style.backgroundColor = `rgb(0, 0, ${b})`;
                    livePreview.style.backgroundColor = hex;
                    livePreview.style.opacity = a;
                    updateColor(hex, a);
                }
            };

            const syncSliderAndNumber = (slider, number, previewBox, channel) => {
                slider.addEventListener('input', () => {
                    if (channel === 'opacity') {
                        const value = parseFloat(slider.value) || 0;
                        number.value = Math.round(value * 100); // Convert decimal to percentage
                        updatePreview(); // Update live preview with opacity
                    } else {
                        number.value = slider.value;
                        updatePreview();
                        const value = parseInt(slider.value) || 0;
                        if (channel === 'r') {
                            previewBox.style.backgroundColor = `rgb(${value}, 0, 0)`;
                        } else if (channel === 'g') {
                            previewBox.style.backgroundColor = `rgb(0, ${value}, 0)`;
                        } else if (channel === 'b') {
                            previewBox.style.backgroundColor = `rgb(0, 0, ${value})`;
                        }
                    }
                });
                number.addEventListener('input', () => {
                    if (channel === 'opacity') {
                        let value = parseFloat(number.value) || 0;
                        if (value < 0) value = 0;
                        if (value > 100) value = 100;
                        slider.value = value / 100; // Convert percentage to decimal
                        number.value = value;
                        updatePreview(); // Update live preview with opacity
                    } else {
                        let value = parseInt(number.value) || 0;
                        if (value < 0) value = 0;
                        if (value > 255) value = 255;
                        slider.value = value;
                        number.value = value;
                        updatePreview();
                        if (channel === 'r') {
                            previewBox.style.backgroundColor = `rgb(${value}, 0, 0)`;
                        } else if (channel === 'g') {
                            previewBox.style.backgroundColor = `rgb(0, ${value}, 0)`;
                        } else if (channel === 'b') {
                            previewBox.style.backgroundColor = `rgb(0, 0, ${value})`;
                        }
                    }
                });
                number.addEventListener('keypress', e => {
                    if (e.key === 'Enter') {
                        updateFromRGB();
                    }
                });
            };

            const rgbPreviewBoxes = modal.querySelectorAll(`#${modalId}-hexrgb .rgb-preview-box`);
            syncSliderAndNumber(rgbSliders[0], rgbNumbers[0], rgbPreviewBoxes[0], 'r');
            syncSliderAndNumber(rgbSliders[1], rgbNumbers[1], rgbPreviewBoxes[1], 'g');
            syncSliderAndNumber(rgbSliders[2], rgbNumbers[2], rgbPreviewBoxes[2], 'b');
            syncSliderAndNumber(opacitySlider, opacityNumber, livePreview, 'opacity');

            hexInput.addEventListener('input', updateFromHex);
            hexInput.addEventListener('keypress', e => {
                if (e.key === 'Enter') updateFromHex();
            });

            confirmBtn.addEventListener('click', () => {
                const r = parseInt(rgbNumbers[0].value) || 0;
                const g = parseInt(rgbNumbers[1].value) || 0;
                const b = parseInt(rgbNumbers[2].value) || 0;
                const a = parseFloat(opacityNumber.value) / 100 || 0;
                if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255 && a >= 0 && a <= 1) {
                    const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    updateColor(hex, a);
                }
            });

            colorPreview.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.color-picker-modal').forEach(m => {
                    if (m !== modal) m.style.display = 'none';
                });
                modal.style.display = modal.style.display === 'none' ? 'block' : 'none';
                modal.style.left = `${e.pageX}px`;
                modal.style.top = `${e.pageY + 10}px`;
            });

            document.addEventListener('click', (e) => {
                if (!modal.contains(e.target) && e.target !== colorPreview) {
                    modal.style.display = 'none';
                }
            }, { once: false });

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.style.width = '80px';
            nameInput.placeholder = '前緣名稱';
            nameInput.value = datasetMap.get(fileName).name || '';
            nameInput.addEventListener('blur', () => {
                datasetMap.get(fileName).name = nameInput.value.trim();
                drawChart();
            });
            nameInput.addEventListener('keypress', e => {
                if (e.key === 'Enter') {
                    nameInput.blur();
                }
            });

            const delBtn = document.createElement('button');
            delBtn.textContent = '刪除';
            delBtn.onclick = () => {
                datasetMap.delete(fileName);
                entry.remove();
                drawChart();
            };

            entry.appendChild(colorPreview);
            entry.appendChild(nameInput);
            entry.appendChild(document.createTextNode(datasetMap.get(fileName).simplifiedName));
            entry.appendChild(delBtn);
            container.appendChild(entry);
            document.getElementById('resetColorsBtn').style.display = datasetMap.size > 0 ? 'inline-block' : 'none';
        }

        function drawChart() {
            const ctx = document.getElementById('riskProfitChart').getContext('2d');
            if (chartInstance) chartInstance.destroy();
            combinedFront = datasetMap.size >= 2 ? combineNonDominatedSets(datasetMap) : null;
            const datasets = Array.from(datasetMap.entries()).map(([fileName, { data, color, name }]) => ({
                label: name || fileName,
                data: data,
                backgroundColor: color,
                borderColor: color,
                pointRadius: 2,
                hoverRadius: 5, // 確保懸停時點大小不變
                showLine: true,
                fill: false,
                tension: 0,
                dragData: false
            }));
            if (combinedFront && combinedFront.risk.length > 0) {
                const combinedData = [];
                for (let i = 0; i < combinedFront.risk.length; i++) {
                    combinedData.push({
                        x: combinedFront.risk[i],
                        y: combinedFront.profit[i]
                    });
                }
                datasets.push({
                    label: 'Combined Front',
                    data: combinedData,
                    backgroundColor: '#000000',
                    borderColor: '#000000',
                    pointRadius: 5,
                    hoverRadius: 5, // 確保懸停時點大小不變
                    showLine: true,
                    fill: false,
                    tension: 0,
                    borderWidth: 2,
                    borderDash: [5, 5],
                    dragData: false
                });
            }
            const minX = parseFloat(minRiskInput.value);
            const maxX = parseFloat(maxRiskInput.value);
            const minY = parseFloat(minProfitInput.value);
            const maxY = parseFloat(maxProfitInput.value);
            const xMin = isNaN(minX) ? undefined : minX;
            const xMax = isNaN(maxX) ? undefined : maxX;
            const yMin = isNaN(minY) ? undefined : minY;
            const yMax = isNaN(maxY) ? undefined : maxY;

            // Get selected date and format title
            const selectedDate = document.querySelector('.date-entry.selected');
            let title = 'Compared of Multiple Algorithms';
            if (selectedDate) {
                const year = selectedDate.dataset.year;
                const month = selectedDate.dataset.month;
                const monthNames = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.'];
                const monthName = monthNames[parseInt(month, 10) - 1] || 'Unknown';
                title = `Compared of Multiple Algorithms in ${monthName} ${year}`;
            }
            chartInstance = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: title, // Dynamic title with date
                            font: {
                                family: 'Times New Roman',
                                size: 32,
                                weight: 'bold'
                            },
                            color: '#000'
                        },
                        tooltip: {
                            titleFont: {
                                family: 'Times New Roman',
                                size: 14
                            },
                            bodyFont: {
                                family: 'Times New Roman',
                                size: 14
                            },
                            callbacks: {
                                label: function (context) {
                                    const label = context.dataset.label;
                                    const x = context.parsed.x.toFixed(2);
                                    const y = context.parsed.y.toFixed(2);
                                    return `${label}: (${x}, ${y})`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                font: {
                                    family: 'Times New Roman',
                                    size: 14,
                                    weight: 'bold'
                                },
                                color: '#000000'
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                threshold: 5,
                            },
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                mode: 'xy',
                            }
                        },
                        dragData: {
                            enabled: true,
                            onDragStart: function (e, datasetIndex, index, value) {
                                console.log('Drag started:', datasetIndex, index, value);
                            },
                            onDrag: function (e, datasetIndex, index, value) {
                                const fileName = Array.from(datasetMap.keys())[datasetIndex];
                                const dataset = datasetMap.get(fileName);
                                dataset.data[index] = { x: value.x, y: value.y };
                                datasetMap.set(fileName, dataset);
                            },
                            onDragEnd: function (e, datasetIndex, index, value) {
                                const fileName = Array.from(datasetMap.keys())[datasetIndex];
                                const dataset = datasetMap.get(fileName);
                                dataset.data[index] = { x: value.x, y: value.y };
                                datasetMap.set(fileName, dataset);
                                drawChart(); // Redraw chart and recalculate metrics
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Daily Risk',
                                font: {
                                    family: 'Times New Roman',
                                    size: 24,
                                    weight: 'bold'
                                },
                                color: '#000000'
                            },
                            ticks: {
                                font: {
                                    family: 'Times New Roman',
                                    size: 20,
                                    weight: 'bold'
                                },
                                color: '#000000'
                            },
                            min: xMin,
                            max: xMax
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Daily Expected Return',
                                font: {
                                    family: 'Times New Roman',
                                    size: 24,
                                    weight: 'bold'
                                },
                                color: '#000000'
                            },
                            ticks: {
                                font: {
                                    family: 'Times New Roman',
                                    size: 20,
                                    weight: 'bold'
                                },
                                color: '#000000'
                            },
                            min: yMin,
                            max: yMax
                        }
                    }
                }
            });
            document.getElementById('chart-container').style.display = 'block';
            document.getElementById('chart-container').style.margin = '20px auto';
            document.getElementById('chart-container').addEventListener('dblclick', function () {
                chartInstance.resetZoom();
            });
            calculateMetrics();
            document.getElementById('resetColorsBtn').style.display = datasetMap.size > 0 ? 'inline-block' : 'none';
        }
    </script>
</body>

</html>