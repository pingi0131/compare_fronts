<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <title>fronts' compare & metrics</title>
    <link rel="stylesheet" href="css/index.css">

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-dragdata@2.2.2/dist/chartjs-plugin-dragdata.min.js"></script>
    <script>
        // 偵測是否為舊瀏覽器（缺少 ES6 關鍵功能）
        if (!window.Promise || !Array.prototype.find) {
            var s = document.createElement('script');
            s.src = 'https://polyfill.io/v3/polyfill.min.js?features=es6';
            s.defer = true;
            document.head.appendChild(s);
        }
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        // KD-Tree implementation (unchanged)
        (function (root, factory) {
            if (typeof define === 'function' && define.amd) {
                define(['exports'], factory);
            } else if (typeof exports === 'object') {
                factory(exports);
            } else {
                factory((root.kdt = {}));
            }
        }(this, function (exports) {
            function Node(obj, dimension, parent) {
                this.obj = obj;
                this.left = null;
                this.right = null;
                this.parent = parent;
                this.dimension = dimension;
            }
            function kdTree(points, metric, dimensions) {
                var self = this;
                function buildTree(points, depth, parent) {
                    var dim = depth % dimensions.length,
                        median,
                        node;
                    if (points.length === 0) {
                        return null;
                    }
                    if (points.length === 1) {
                        return new Node(points[0], dim, parent);
                    }
                    points.sort(function (a, b) {
                        return a[dimensions[dim]] - b[dimensions[dim]];
                    });
                    median = Math.floor(points.length / 2);
                    node = new Node(points[median], dim, parent);
                    node.left = buildTree(points.slice(0, median), depth + 1, node);
                    node.right = buildTree(points.slice(median + 1), depth + 1, node);
                    return node;
                }
                this.root = buildTree(points, 0, null);
                this.nearest = function (point, maxNodes, maxDistance) {
                    var i,
                        result,
                        bestNodes;
                    bestNodes = new BinaryHeap(
                        function (e) { return -e[1]; }
                    );
                    function nearestSearch(node) {
                        var bestChild,
                            dimension = dimensions[node.dimension],
                            ownDistance = metric(point, node.obj),
                            linearPoint = {},
                            linearDistance,
                            otherChild,
                            i;
                        function saveNode(node, distance) {
                            bestNodes.push([node, distance]);
                            if (bestNodes.size() > maxNodes) {
                                bestNodes.pop();
                            }
                        }
                        for (i = 0; i < dimensions.length; i += 1) {
                            if (i === node.dimension) {
                                linearPoint[dimensions[i]] = point[dimensions[i]];
                            } else {
                                linearPoint[dimensions[i]] = node.obj[dimensions[i]];
                            }
                        }
                        linearDistance = metric(linearPoint, node.obj);
                        if (node.right === null && node.left === null) {
                            if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                                saveNode(node.obj, ownDistance);
                            }
                            return;
                        }
                        if (node.right === null) {
                            bestChild = node.left;
                        } else if (node.left === null) {
                            bestChild = node.right;
                        } else {
                            if (point[dimension] < node.obj[dimension]) {
                                bestChild = node.left;
                            } else {
                                bestChild = node.right;
                            }
                        }
                        nearestSearch(bestChild);
                        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                            saveNode(node.obj, ownDistance);
                        }
                        if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {
                            if (bestChild === node.left) {
                                otherChild = node.right;
                            } else {
                                otherChild = node.left;
                            }
                            if (otherChild !== null) {
                                nearestSearch(otherChild);
                            }
                        }
                    }
                    if (maxDistance) {
                        for (i = 0; i < maxNodes; i += 1) {
                            bestNodes.push([null, maxDistance]);
                        }
                    }
                    if (self.root) {
                        nearestSearch(self.root);
                    }
                    result = [];
                    for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {
                        if (bestNodes.content[i][0]) {
                            result.push([bestNodes.content[i][0], bestNodes.content[i][1]]);
                        }
                    }
                    return result;
                };
            }
            function BinaryHeap(scoreFunction) {
                this.content = [];
                this.scoreFunction = scoreFunction;
            }
            BinaryHeap.prototype = {
                push: function (element) {
                    this.content.push(element);
                    this.bubbleUp(this.content.length - 1);
                },
                pop: function () {
                    var result = this.content[0];
                    var end = this.content.pop();
                    if (this.content.length > 0) {
                        this.content[0] = end;
                        this.sinkDown(0);
                    }
                    return result;
                },
                peek: function () {
                    return this.content[0];
                },
                size: function () {
                    return this.content.length;
                },
                bubbleUp: function (n) {
                    var element = this.content[n],
                        score = this.scoreFunction(element);
                    while (n > 0) {
                        var parentN = Math.floor((n + 1) / 2) - 1,
                            parent = this.content[parentN];
                        if (score >= this.scoreFunction(parent)) {
                            break;
                        }
                        this.content[parentN] = element;
                        this.content[n] = parent;
                        n = parentN;
                    }
                },
                sinkDown: function (n) {
                    var length = this.content.length,
                        element = this.content[n],
                        elemScore = this.scoreFunction(element);
                    while (true) {
                        var child2N = (n + 1) * 2,
                            child1N = child2N - 1;
                        var swap = null;
                        var child1Score;
                        if (child1N < length) {
                            var child1 = this.content[child1N];
                            child1Score = this.scoreFunction(child1);
                            if (child1Score < elemScore) {
                                swap = child1N;
                            }
                        }
                        if (child2N < length) {
                            var child2 = this.content[child2N],
                                child2Score = this.scoreFunction(child2);
                            if (child2Score < (swap === null ? elemScore : child1Score)) {
                                swap = child2N;
                            }
                        }
                        if (swap === null) {
                            break;
                        }
                        this.content[n] = this.content[swap];
                        this.content[swap] = element;
                        n = swap;
                    }
                }
            };
            exports.kdTree = kdTree;
            exports.BinaryHeap = BinaryHeap;
        }));
    </script>
    <script>
        window.MathJax = {
            chtml: { scale: 1.5 }
        };
    </script>
    
</head>

<body>
    <div class="data-source-container">
        <select id="dataSourceSelect">
            <option value="WPM_MoQTS" data-min-year="2021" data-min-month="12" data-max-year="2024" data-max-month="11">
                WPM MoQTS</option>
            <option value="WPM_MoQA" data-min-year="2021" data-min-month="12" data-max-year="2025" data-max-month="4">
                WPM MoQA</option>
            <option value="WPM_Hybird" data-min-year="2021" data-min-month="12" data-max-year="2025" data-max-month="4">
                WPM Hybrid</option>
            <option value="Hybrid_ELS_BA" data-min-year="2021" data-min-month="12" data-max-year="2025"
                data-max-month="4">
                ELS effect</option>
            <option value="EPM_H-MoQTS" data-min-year="2023" data-min-month="1" data-max-year="2025" data-max-month="4">
                EPM H-MoQTS</option>
        </select>
    </div>

    <div class="date-inputs">
        <input type="number" id="yearInput" placeholder="Year" min="2023" max="2025" step="1">
        <input type="number" id="monthInput" placeholder="Month" min="1" max="12" step="1">
        <button id="loadDateBtn" class="reset-btn">✔️</button>
    </div>
    <div class="sidebar-trigger" id="sidebarTrigger"></div>
    <div class="sidebar" id="dateSidebar">
        <!-- Date entries will be populated by JavaScript -->
    </div>
    <div class="main-content">
        <h1>多檔前緣比較圖 指標計算<a href="https://pingi0131.github.io/compare_fronts/guide.html" class="help-link">Help</a>
            <a href="https://pingi0131.github.io/compare_fronts/upload_custom_front.html"
                class="menu-link">Customize</a>
        </h1>

        <div class="range-controls">
            <label class="math-label">\( f_1(x) \)</label>
            <input type="number" id="minRisk" placeholder="Min" step="1">
            <button class="reset-range-btn" onclick="resetField('minRisk')"></button>
            <span class="tilde">-</span>
            <input type="number" id="maxRisk" placeholder="Max" step="1">
            <button class="reset-range-btn" onclick="resetField('maxRisk')"></button>
              
            <label>\( f_2(x) \)</label>
            <input type="number" id="minProfit" placeholder="Min" step="1">
            <button class="reset-range-btn" onclick="resetField('minProfit')"></button>
            <span class="tilde">-</span>
            <input type="number" id="maxProfit" placeholder="Max" step="1">
            <button class="reset-range-btn" onclick="resetField('maxProfit')"></button>
              
            <button class="reset-btn" onclick="resetAllRanges()">All</button>
        </div>
        <div id="fileListContainer" class="controls"></div>
        <button id="resetColorsBtn" class="reset-btn" onclick="resetColors()" style="display: none;">重置所有顏色</button>
        <div id="chart-container">
            <canvas id="riskProfitChart"></canvas>
        </div>
        <div id="metricsOutput" class="metrics-results" style="display: none;"></div>
        <button id="showTableBtn" class="show-table-btn">精緻表格</button>
        <div id="metricsTableContainer" style="display: none; margin-top: 20px;">
            <table id="metricsTable" border="1"
                style="border-collapse: collapse; width: 100%; max-width: 960px; margin: 0 auto;">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>#NDS</th>
                        <th>HV</th>
                        <th>HV Rate</th>
                        <th>Hit Rate</th>
                        <th>GD</th>
                        <th>IGD</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    <script src="js/index.js"></script>
</body>

</html>