<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <title>fronts' compare & metrics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>

    <script>
        // 偵測是否為舊瀏覽器（缺少 ES6 關鍵功能）
        if (!window.Promise || !Array.prototype.find) {
            var s = document.createElement('script');
            s.src = 'https://polyfill.io/v3/polyfill.min.js?features=es6';
            s.defer = true;
            document.head.appendChild(s);
        }
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        // KD-Tree implementation (unchanged)
        (function (root, factory) {
            if (typeof define === 'function' && define.amd) {
                define(['exports'], factory);
            } else if (typeof exports === 'object') {
                factory(exports);
            } else {
                factory((root.kdt = {}));
            }
        }(this, function (exports) {
            function Node(obj, dimension, parent) {
                this.obj = obj;
                this.left = null;
                this.right = null;
                this.parent = parent;
                this.dimension = dimension;
            }
            function kdTree(points, metric, dimensions) {
                var self = this;
                function buildTree(points, depth, parent) {
                    var dim = depth % dimensions.length,
                        median,
                        node;
                    if (points.length === 0) {
                        return null;
                    }
                    if (points.length === 1) {
                        return new Node(points[0], dim, parent);
                    }
                    points.sort(function (a, b) {
                        return a[dimensions[dim]] - b[dimensions[dim]];
                    });
                    median = Math.floor(points.length / 2);
                    node = new Node(points[median], dim, parent);
                    node.left = buildTree(points.slice(0, median), depth + 1, node);
                    node.right = buildTree(points.slice(median + 1), depth + 1, node);
                    return node;
                }
                this.root = buildTree(points, 0, null);
                this.nearest = function (point, maxNodes, maxDistance) {
                    var i,
                        result,
                        bestNodes;
                    bestNodes = new BinaryHeap(
                        function (e) { return -e[1]; }
                    );
                    function nearestSearch(node) {
                        var bestChild,
                            dimension = dimensions[node.dimension],
                            ownDistance = metric(point, node.obj),
                            linearPoint = {},
                            linearDistance,
                            otherChild,
                            i;
                        function saveNode(node, distance) {
                            bestNodes.push([node, distance]);
                            if (bestNodes.size() > maxNodes) {
                                bestNodes.pop();
                            }
                        }
                        for (i = 0; i < dimensions.length; i += 1) {
                            if (i === node.dimension) {
                                linearPoint[dimensions[i]] = point[dimensions[i]];
                            } else {
                                linearPoint[dimensions[i]] = node.obj[dimensions[i]];
                            }
                        }
                        linearDistance = metric(linearPoint, node.obj);
                        if (node.right === null && node.left === null) {
                            if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                                saveNode(node.obj, ownDistance);
                            }
                            return;
                        }
                        if (node.right === null) {
                            bestChild = node.left;
                        } else if (node.left === null) {
                            bestChild = node.right;
                        } else {
                            if (point[dimension] < node.obj[dimension]) {
                                bestChild = node.left;
                            } else {
                                bestChild = node.right;
                            }
                        }
                        nearestSearch(bestChild);
                        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
                            saveNode(node.obj, ownDistance);
                        }
                        if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {
                            if (bestChild === node.left) {
                                otherChild = node.right;
                            } else {
                                otherChild = node.left;
                            }
                            if (otherChild !== null) {
                                nearestSearch(otherChild);
                            }
                        }
                    }
                    if (maxDistance) {
                        for (i = 0; i < maxNodes; i += 1) {
                            bestNodes.push([null, maxDistance]);
                        }
                    }
                    if (self.root) {
                        nearestSearch(self.root);
                    }
                    result = [];
                    for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {
                        if (bestNodes.content[i][0]) {
                            result.push([bestNodes.content[i][0], bestNodes.content[i][1]]);
                        }
                    }
                    return result;
                };
            }
            function BinaryHeap(scoreFunction) {
                this.content = [];
                this.scoreFunction = scoreFunction;
            }
            BinaryHeap.prototype = {
                push: function (element) {
                    this.content.push(element);
                    this.bubbleUp(this.content.length - 1);
                },
                pop: function () {
                    var result = this.content[0];
                    var end = this.content.pop();
                    if (this.content.length > 0) {
                        this.content[0] = end;
                        this.sinkDown(0);
                    }
                    return result;
                },
                peek: function () {
                    return this.content[0];
                },
                size: function () {
                    return this.content.length;
                },
                bubbleUp: function (n) {
                    var element = this.content[n],
                        score = this.scoreFunction(element);
                    while (n > 0) {
                        var parentN = Math.floor((n + 1) / 2) - 1,
                            parent = this.content[parentN];
                        if (score >= this.scoreFunction(parent)) {
                            break;
                        }
                        this.content[parentN] = element;
                        this.content[n] = parent;
                        n = parentN;
                    }
                },
                sinkDown: function (n) {
                    var length = this.content.length,
                        element = this.content[n],
                        elemScore = this.scoreFunction(element);
                    while (true) {
                        var child2N = (n + 1) * 2,
                            child1N = child2N - 1;
                        var swap = null;
                        var child1Score;
                        if (child1N < length) {
                            var child1 = this.content[child1N];
                            child1Score = this.scoreFunction(child1);
                            if (child1Score < elemScore) {
                                swap = child1N;
                            }
                        }
                        if (child2N < length) {
                            var child2 = this.content[child2N],
                                child2Score = this.scoreFunction(child2);
                            if (child2Score < (swap === null ? elemScore : child1Score)) {
                                swap = child2N;
                            }
                        }
                        if (swap === null) {
                            break;
                        }
                        this.content[n] = this.content[swap];
                        this.content[swap] = element;
                        n = swap;
                    }
                }
            };
            exports.kdTree = kdTree;
            exports.BinaryHeap = BinaryHeap;
        }));
    </script>
    <script>
        window.MathJax = {
            chtml: { scale: 1.5 }
        };
    </script>
    <style>
        body {
            font-family: '標楷體', 'Times New Roman', serif;
            padding: 28px;
        }

        #chart-container {
            width: 100%;
            max-width: 960px;
            aspect-ratio: 16 / 10;
            margin: 20px auto 0;
            display: none;
        }

        canvas {
            width: 100% !important;
            height: auto !important;
        }

        h1 {
            margin-top: 0px;
            margin-bottom: 20px;
        }

        .controls,
        .range-controls {
            font-size: 20px;
            margin: 12px 0;
        }

        .controls input[type="file"] {
            font-size: 18px;
        }

        .range-controls label,
        .range-controls input[type="number"],
        .range-controls button {
            font-size: 18px;
            font-family: "標楷體", "PMingLiU", serif;
            font-weight: bold;
        }

        .reset-range-btn {
            background-image: url('./png/reset.png');
            background-size: 130%;
            background-repeat: no-repeat;
            background-position: center;
            width: 30px;
            height: 30px;
            border: none;
            outline: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            position: relative;
            display: inline-block;
            background-color: transparent;
            vertical-align: middle;
        }

        .reset-range-btn:hover::after {
            content: "reset";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            color: black;
            padding: 5px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
        }

        .reset-range-btn:active {
            transform: scale(0.9);
        }

        .tilde {
            font-size: 1.5em;
            vertical-align: middle;
        }

        .file-entry {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
            margin: 6px 0;
        }

        .math-label {
            font-size: 28px;
        }

        input[type="text"],
        input[type="number"] {
            padding: 2px 4px;
        }

        input[type="number"] {
            width: 80px;
            padding: 2px 4px;
            font-size: 0.9em;
            height: 30px;
            vertical-align: middle;
        }

        button {
            background-color: #c00;
            color: white;
            border: none;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 4px;
        }

        button:hover {
            background-color: #900;
        }

        .reset-btn {
            margin-left: 4px;
            background-color: #007BFF;
        }

        .reset-btn:hover {
            background-color: #0056b3;
        }

        .metrics-results {
            margin-top: 20px;
            font-family: monospace;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 6px;
            white-space: pre;
        }

        #metricsTable {
            font-family: monospace;
            font-size: 16px;
            text-align: center;
            table-layout: fixed;
            width: 100%;
        }

        #metricsTable th,
        #metricsTable td {
            padding: 10px;
            border: 1px solid #ccc;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #metricsTable th {
            background-color: #f0f0f0;
            font-weight: bold;
        }

        #metricsTable th,
        #metricsTable td {
            width: calc(100% / 7);
        }

        #metricsTable td.best {
            color: red;
            font-weight: bold;
        }

        #metricsTable tr.combined-front {
            background-color: #e0f0ff;
            font-weight: bold;
        }

        #metricsTable tbody tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        #metricsTable tbody tr:hover {
            background-color: #e0e0e0;
        }

        /* Custom Color Picker Modal Styles */
        .color-picker-modal {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            padding: 10px;
            border-radius: 5px;
            /*width: 345px;*/
        }

        .color-picker-tabs {
            display: grid;
            grid-template-columns: repeat(3, 115px);
            /* Fixed width of 115px for each tab (345px total / 3) */
            border-bottom: 1px solid #ccc;
            margin-bottom: 10px;
        }

        .color-picker-tabs button {
            padding: 5px;
            background: #f0f0f0;
            color: #333333;
            border: none;
            cursor: pointer;
            font-size: 14px;
            border-radius: 3px 3px 0 0;
            text-align: center;
        }

        .color-picker-content input[type="color"] {
            width: 115px;
            /* Match tab width */
            height: 40px;
            border: none;
            outline: none;
            cursor: pointer;
            background: transparent;
            padding: 0;
        }

        .color-picker-tabs button.active {
            background: #007BFF;
            /* Blue background for active tab */
            color: white;
            /* White text for contrast */
            border-bottom: 2px solid #0056b3;
            /* Darker blue border */
        }

        .color-picker-tabs button:hover {
            background: #d0d0d0;
            /* Slightly darker hover for better contrast */
            color: #000000;
        }

        .color-picker-content {
            display: none;
        }

        .color-picker-content.active {
            display: block;
        }

        .common-colors {
            display: grid;
            grid-template-columns: repeat(10, 30px);
            /* 10 columns for the first row */
            grid-auto-rows: 30px;
            /* Ensure each row is 40px tall */
            gap: 5px;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            cursor: pointer;
            border-radius: 3px;
        }

        .color-swatch:hover {
            border-color: #000;
        }

        .hexrgb-inputs {
            display: grid;
            gap: 8px;
        }

        .hexrgb-inputs label {
            font-size: 14px;
            display: grid;
            grid-template-columns: 60px 115px 60px;
            align-items: center;
            gap: 5px;
        }

        .hexrgb-inputs input.rgb-slider {
            width: 115px;
        }

        .hexrgb-inputs input.rgb-slider,
        .hexrgb-inputs input.opacity-slider {
            width: 100%;
        }

        .hexrgb-inputs input.rgb-number,
        .hexrgb-inputs input.opacity-number {
            width: 50px;
            padding: 3px;
            font-size: 14px;
        }

        .hexrgb-inputs input.hex-input {
            width: 100%;
            padding: 5px;
            font-family: monospace;
            font-size: 14px;
        }

        .hexrgb-inputs .confirm-btn {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 14px;
            justify-self: center;
        }

        .hexrgb-inputs .confirm-btn:hover {
            background-color: #0056b3;
        }

        .rgb-inputs input {
            width: 60px;
            padding: 3px;
            font-size: 14px;
        }

        .color-preview-box {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            display: inline-block;
            vertical-align: middle;
            cursor: pointer;
            border-radius: 3px;
        }

        .color-preview-box:hover {
            border-color: #000;
        }
    </style>
</head>

<body>
    <h1>多檔前緣比較圖 指標計算</h1>
    <div class="range-controls">
        <label class="math-label">\( f_1(x) \)</label>
        <input type="number" id="minRisk" placeholder="Min" step="1">
        <button class="reset-range-btn" onclick="resetField('minRisk')"></button>
        <span class="tilde">-</span>
        <input type="number" id="maxRisk" placeholder="Max" step="1">
        <button class="reset-range-btn" onclick="resetField('maxRisk')"></button>
          
        <label>\( f_2(x) \)</label>
        <input type="number" id="minProfit" placeholder="Min" step="1">
        <button class="reset-range-btn" onclick="resetField('minProfit')"></button>
        <span class="tilde">-</span>
        <input type="number" id="maxProfit" placeholder="Max" step="1">
        <button class="reset-range-btn" onclick="resetField('maxProfit')"></button>
          
        <button class="reset-btn" onclick="resetAllRanges()">All</button>
    </div>
    <div class="controls">
        <label>選擇年月：</label>
        <input type="number" id="yearInput" placeholder="年份 (例如: 2024)" min="1900" max="2100" style="width: 100px;">
        <input type="number" id="monthInput" placeholder="月份 (1-12)" min="1" max="12" style="width: 80px;">
        <button id="loadFilesBtn">載入檔案</button>
    </div>
    <div id="fileListContainer" class="controls"></div>
    <button id="resetColorsBtn" class="reset-btn" onclick="resetColors()" style="display: none;">重置所有顏色</button>
    <div id="chart-container">
        <canvas id="riskProfitChart"></canvas>
    </div>
    <div id="metricsOutput" class="metrics-results" style="display: none;"></div>
    <button id="showTableBtn" class="reset-btn" style="display: none;">顯示統整好看表格</button>
    <div id="metricsTableContainer" style="display: none; margin-top: 20px;">
        <table id="metricsTable" border="1"
            style="border-collapse: collapse; width: 100%; max-width: 960px; margin: 0 auto;">
            <thead>
                <tr>
                    <th>前緣名稱</th>
                    <th>#NDS</th>
                    <th>HV</th>
                    <th>HV Rate</th>
                    <th>Hit Rate</th>
                    <th>GD</th>
                    <th>IGD</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <script>
        let chartInstance = null;
        const datasetMap = new Map();
        const defaultColors = ['#0000FF', '#FFA500', '#888888', '#FF0000', '#00AA00'];
        let combinedFront = null;
        // 新增讀取目錄檔案的函數
        async function loadFilesFromData() {
            const year = document.getElementById('yearInput').value;
            const month = document.getElementById('monthInput').value;

            if (!year || !month) {
                alert('請輸入有效的年份和月份');
                return;
            }

            // Ensure month is zero-padded (e.g., "1" becomes "01")
            const paddedMonth = month.padStart(2, '0');
            const pattern = `${year}_${paddedMonth}`; // e.g., "2024_01"

            try {
                // Clear existing data
                datasetMap.clear();
                document.getElementById('fileListContainer').innerHTML = '';

                // Recursively collect all CSV files from ./data
                const allFiles = await loadFilesFromDataDir('./data/');
                if (!allFiles || allFiles.length === 0) {
                    alert(`在 ./data 中找不到任何 CSV 檔案`);
                    return;
                }

                // Filter files that match the pattern and end with .csv
                const matchingFiles = allFiles.filter(file =>
                    file.includes(pattern) && file.endsWith('.csv')
                );

                if (matchingFiles.length === 0) {
                    alert(`找不到包含 "${pattern}" 的 CSV 檔案`);
                    return;
                }

                // Load each matching file
                for (const filePath of matchingFiles) {
                    try {
                        const fileResponse = await fetch(filePath);
                        if (!fileResponse.ok) {
                            console.error(`無法讀取檔案 ${filePath}: ${fileResponse.status}`);
                            continue;
                        }

                        const text = await fileResponse.text();
                        const lines = text.split(/\r?\n/);
                        if (lines.length === 0) continue;

                        const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                        const riskIndex = headers.findIndex(h => h.includes('risk'));
                        const profitIndex = headers.findIndex(h => h.includes('profit') || h.includes('return'));

                        if (riskIndex === -1 || profitIndex === -1) continue;

                        const parsedSet = new Set();
                        const parsed = [];

                        for (let i = 1; i < lines.length; i++) {
                            const line = lines[i].trim();
                            if (!line) continue;

                            const cols = line.split(',');
                            const x = parseFloat(cols[riskIndex]);
                            const y = parseFloat(cols[profitIndex]);
                            const key = `${x},${y}`;

                            if (!isNaN(x) && !isNaN(y) && !(x === 0 && y === 0) && !parsedSet.has(key)) {
                                parsedSet.add(key);
                                parsed.push({ x, y });
                            }
                        }

                        if (parsed.length > 0) {
                            const color = defaultColors[datasetMap.size % defaultColors.length] || '#000000';
                            // Use the file name without the full path for display
                            const fileName = filePath.split('/').pop();
                            datasetMap.set(fileName, {
                                name: '',
                                data: parsed.sort((a, b) => a.x - b.x),
                                color
                            });
                            addFileEntryUI(fileName, color);
                        }
                    } catch (fileError) {
                        console.error(`處理檔案 ${filePath} 時發生錯誤:`, fileError);
                    }
                }

                if (datasetMap.size > 0) {
                    drawChart();
                    document.getElementById('resetColorsBtn').style.display = datasetMap.size > 0 ? 'inline-block' : 'none';
                    calculateMetrics();
                } else {
                    alert(`沒有成功載入任何符合 "${pattern}" 的有效 CSV 檔案`);
                }
            } catch (error) {
                console.error('讀取目錄時發生錯誤:', error);
                alert(`讀取目錄時發生錯誤: ${error.message}`);
            }
        }

        // Helper function to recursively fetch all files
        async function loadFilesFromDataDir() {
  const year = document.getElementById('yearInput').value;
  const month = document.getElementById('monthInput').value;

  if (!year || !month) {
    alert('請輸入有效的年份和月份');
    return;
  }

  // Ensure month is zero-padded (e.g., "1" becomes "01")
  const paddedMonth = month.padStart(2, '0');
  const pattern = `${year}_${paddedMonth}`; // e.g., "2024_01"

  // Explicitly list the CSV files (adjust this list based on your files)
  // https://pingi0131.github.io/compare_fronts/data/UA_2023_01_front.csv
  const csvFiles = [
    `MoQTS/UA_${year}_${paddedMonth}%28${year}%20Q1%29_60%23_front.csv`,
    `SMS-EMOA/NIKKEI30%26DJIA30_2015-2024_SMS-EMOA_3_999_100_10M_M2M_Pareto_Front_${year}_${paddedMonth}%28${year}%20Q1%29.csv`,
    `MOEAD/NIKKEI30&DJIA30_2015-2024_MOEAD_3_999_100_10_10_10M_M2M_Pareto_Front_${year}_${paddedMonth}%28${year}%20Q1%29.csv`,
    `NSGA-II%28M2M%29/NSGA_train_${year}_${paddedMonth}%28${year}%20Q1%29.csv`
    // Add more files as needed, e.g., `data/2024_01_example.csv`
  ];

  try {
    // Clear existing data
    datasetMap.clear();
    document.getElementById('fileListContainer').innerHTML = '';

    // Load each specified file
    for (const filePath of csvFiles) {
        //alert(`${filePath}`)
      try {
        const fileResponse = await fetch(`https://pingi0131.github.io/compare_fronts/data/${filePath}`);
        if (!fileResponse.ok) {
          console.error(`無法讀取檔案 ${filePath}: ${fileResponse.status}`);
          continue;
        }

        const text = await fileResponse.text();
        const lines = text.split(/\r?\n/);
        if (lines.length === 0) continue;

        const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
        const riskIndex = headers.findIndex(h => h.includes('risk'));
        const profitIndex = headers.findIndex(h => h.includes('profit') || h.includes('return'));

        if (riskIndex === -1 || profitIndex === -1) continue;

        const parsedSet = new Set();
        const parsed = [];

        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;

          const cols = line.split(',');
          const x = parseFloat(cols[riskIndex]);
          const y = parseFloat(cols[profitIndex]);
          const key = `${x},${y}`;

          if (!isNaN(x) && !isNaN(y) && !(x === 0 && y === 0) && !parsedSet.has(key)) {
            parsedSet.add(key);
            parsed.push({ x, y });
          }
        }

        if (parsed.length > 0) {
          const color = defaultColors[datasetMap.size % defaultColors.length] || '#000000';
          const fileName = filePath.split('/').pop();
          datasetMap.set(fileName, {
            name: '',
            data: parsed.sort((a, b) => a.x - b.x),
            color
          });
          addFileEntryUI(fileName, color);
        }
      } catch (fileError) {
        console.error(`處理檔案 ${filePath} 時發生錯誤:`, fileError);
      }
    }

    if (datasetMap.size > 0) {
      drawChart();
      document.getElementById('resetColorsBtn').style.display = datasetMap.size > 0 ? 'inline-block' : 'none';
      calculateMetrics();
    } else {
      alert(`沒有成功載入任何符合 "${pattern}" 的有效 CSV 檔案`);
    }
  } catch (error) {
    console.error('載入檔案時發生錯誤:', error);
    alert(`載入檔案時發生錯誤: ${error.message}`);
  }
}
        const minRiskInput = document.getElementById('minRisk');
        const maxRiskInput = document.getElementById('maxRisk');
        const minProfitInput = document.getElementById('minProfit');
        const maxProfitInput = document.getElementById('maxProfit');
        const defaultRanges = {
            minRisk: undefined,
            maxRisk: undefined,
            minProfit: undefined,
            maxProfit: undefined
        };
        [minRiskInput, maxRiskInput, minProfitInput, maxProfitInput].forEach(input => {
            input.addEventListener('blur', drawChart);
            input.addEventListener('keypress', e => { if (e.key === 'Enter') drawChart(); });
        });
        function resetField(fieldId) {
            document.getElementById(fieldId).value = defaultRanges[fieldId] ?? '';
            if (datasetMap.size > 0) {
                drawChart();
            }
        }
        function resetAllRanges() {
            for (const key in defaultRanges) {
                document.getElementById(key).value = defaultRanges[key] ?? '';
            }
            if (datasetMap.size > 0) {
                drawChart();
            }
        }
        function resetColors() {
            const entries = Array.from(datasetMap.entries());
            entries.forEach(([fileName, data], index) => {
                const newColor = defaultColors[index % defaultColors.length] || '#000000';
                data.color = newColor;
                const entryDiv = document.getElementById(`entry-${CSS.escape(fileName)}`);
                if (entryDiv) {
                    const colorPreview = entryDiv.querySelector('.color-preview-box');
                    if (colorPreview) {
                        colorPreview.style.backgroundColor = newColor;
                    }
                }
            });
            if (datasetMap.size > 0) {
                drawChart();
            }
            document.getElementById('resetColorsBtn').style.display = datasetMap.size > 0 ? 'inline-block' : 'none';
        }
        function normalize(data) {
            const allRisks = Object.values(data).flatMap(d => d.risk);
            const allProfits = Object.values(data).flatMap(d => d.profit);
            const minRisk = Math.min(...allRisks);
            const maxRisk = Math.max(...allRisks) * 1.01;
            const minProfit = Math.min(...allProfits) * 0.99;
            const maxProfit = Math.max(...allProfits);
            console.log(`Normalization bounds: min risk:${minRisk}, max risk:${maxRisk}, min profit:${minProfit}, max profit:${maxProfit}`);
            const result = {};
            for (const name in data) {
                const normalizedRisk = [];
                const normalizedProfit = [];
                for (let i = 0; i < data[name].risk.length; i++) {
                    const risk = data[name].risk[i];
                    const profit = data[name].profit[i];
                    const newRisk = (risk - minRisk) / (maxRisk - minRisk);
                    const newProfit = (profit - minProfit) / (maxProfit - minProfit);
                    normalizedRisk.push(newRisk);
                    normalizedProfit.push(newProfit);
                }
                result[name] = {
                    risk: normalizedRisk,
                    profit: normalizedProfit
                };
            }
            return result;
        }
        function combineNonDominatedSets(dataSets) {
            const combinedRisk = [];
            const combinedProfit = [];
            for (const [_, dataSet] of dataSets.entries()) {
                for (let i = 0; i < dataSet.data.length; i++) {
                    const risk = dataSet.data[i].x;
                    const profit = dataSet.data[i].y;
                    let addNew = true;
                    let j = 0;
                    while (j < combinedRisk.length) {
                        if (profit <= combinedProfit[j] && risk >= combinedRisk[j]) {
                            addNew = false;
                            break;
                        }
                        if (profit > combinedProfit[j] && risk < combinedRisk[j]) {
                            combinedRisk.splice(j, 1);
                            combinedProfit.splice(j, 1);
                        } else {
                            j++;
                        }
                    }
                    if (addNew) {
                        combinedRisk.push(risk);
                        combinedProfit.push(profit);
                    }
                }
            }
            const sortedPairs = combinedRisk.map((risk, i) => [risk, combinedProfit[i]])
                .sort((a, b) => a[0] - b[0]);
            const sortedRisk = sortedPairs.map(pair => pair[0]);
            const sortedProfit = sortedPairs.map(pair => pair[1]);
            return {
                risk: sortedRisk,
                profit: sortedProfit
            };
        }
        function calcGD(normalized, frontKey) {
            const result = {};
            const normalizedFront = {
                risk: normalized[frontKey].risk,
                profit: normalized[frontKey].profit
            };
            for (const name in normalized) {
                const data = normalized[name];
                let sumMin = 0.0;
                for (let i = 0; i < data.risk.length; i++) {
                    const risk = data.risk[i];
                    const profit = data.profit[i]; // Fixed: use data.profit[i]
                    let minDis = Infinity;
                    for (let j = 0; j < normalizedFront.risk.length; j++) {
                        const pRisk = normalizedFront.risk[j];
                        const pProfit = normalizedFront.profit[j];
                        const distance = Math.sqrt(Math.pow(pRisk - risk, 2) + Math.pow(pProfit - profit, 2));
                        if (distance < minDis) {
                            minDis = distance;
                        }
                    }
                    sumMin += Math.pow(minDis, 2);
                }
                result[name] = Math.sqrt(sumMin) / data.risk.length;
            }
            return result;
        }
        function calcIGD(normalized, frontKey) {
            const result = {};
            const normalizedFront = {
                risk: normalized[frontKey].risk,
                profit: normalized[frontKey].profit
            };
            for (const name in normalized) {
                const data = normalized[name];
                let sumMin = 0.0;
                for (let j = 0; j < normalizedFront.risk.length; j++) {
                    const pRisk = normalizedFront.risk[j];
                    const pProfit = normalizedFront.profit[j];
                    let minDis = Infinity;
                    for (let i = 0; i < data.risk.length; i++) {
                        const risk = data.risk[i];
                        const profit = data.profit[i];
                        const distance = Math.sqrt(Math.pow(pRisk - risk, 2) + Math.pow(pProfit - profit, 2));
                        if (distance < minDis) {
                            minDis = distance;
                        }
                    }
                    sumMin += Math.pow(minDis, 2);
                }
                result[name] = Math.sqrt(sumMin) / normalizedFront.risk.length;
            }
            return result;
        }
        function calcHV(normalized) {
            const result = {};
            const refPointX = 1.0;
            const refPointY = 0.0;
            for (const name in normalized) {
                let hv = 0;
                const r = normalized[name].risk;
                const p = normalized[name].profit;
                const sortedIndices = Array.from({ length: r.length }, (_, i) => i)
                    .sort((a, b) => r[a] - r[b]);
                let prevProfit = refPointY;
                for (const idx of sortedIndices) {
                    const risk = r[idx];
                    const profit = p[idx];
                    if (profit > prevProfit) {
                        hv += Math.abs((refPointX - risk) * (profit - prevProfit));
                        prevProfit = profit;
                    }
                }
                result[name] = hv;
            }
            return result;
        }
        function calculateHitRate(normalized) {
            const hitRate = {};
            const hitCounts = {};
            const coRisk = normalized["Combined Front"].risk;
            const numCo = coRisk.length;
            for (const name in normalized) {
                let time = 0;
                const otherRisk = normalized[name].risk;
                for (const r of otherRisk) {
                    if (coRisk.some(coR => Math.abs(coR - r) < 1e-10)) {
                        time += 1;
                    }
                }
                hitRate[name] = numCo > 0 ? (time / numCo) * 100 : 0;
                hitCounts[name] = {
                    hits: time,
                    total: numCo
                };
            }
            return {
                percentages: hitRate,
                counts: hitCounts
            };
        }
        function checkAllNames() {
            for (const [fileName, data] of datasetMap) {
                if (!data.name.trim()) {
                    return false;
                }
            }
            return true;
        }
        function calculateMetrics() {
            const showTableBtn = document.getElementById('showTableBtn');
            if (datasetMap.size < 2) {
                document.getElementById('metricsOutput').style.display = 'none';
                document.getElementById('metricsTableContainer').style.display = 'none';
                showTableBtn.style.display = 'none';
                return;
            }
            const rawData = {};
            datasetMap.forEach((value, key) => {
                rawData[key] = {
                    risk: value.data.map(d => d.x),
                    profit: value.data.map(d => d.y)
                };
            });
            const combinedFrontData = combineNonDominatedSets(datasetMap);
            rawData["Combined Front"] = {
                risk: combinedFrontData.risk,
                profit: combinedFrontData.profit
            };
            const normalized = normalize(rawData);
            try {
                const HV = calcHV(normalized);
                const GD = calcGD(normalized, "Combined Front");
                const IGD = calcIGD(normalized, "Combined Front");
                const hitRateResult = calculateHitRate(normalized);
                const hitRate = hitRateResult.percentages;

                let output = '';
                for (const name of Object.keys(normalized)) {
                    // Skip the Combined Front in the output display
                    if (name === "Combined Front") {
                        continue;
                    }

                    const hv = HV[name].toFixed(4);
                    const gd = formatScientific(GD[name], 2);
                    const igd = formatScientific(IGD[name], 2);
                    const hv_value = HV[name].toFixed(20);
                    const gd_value = GD[name].toFixed(20);
                    const igd_value = IGD[name].toFixed(20);

                    // Only show HV, GD, and IGD in the simplified output
                    output += `${name}\nHV:  ${hv} (${hv_value})\nGD:  ${gd} (${gd_value})\nIGD: ${igd} (${igd_value})\n\n`;
                }
                const panel = document.getElementById('metricsOutput');
                panel.textContent = output.trim();
                panel.style.display = 'block';
                showTableBtn.style.display = 'inline-block';
                combinedFront = combinedFrontData;
                document.getElementById('metricsTableContainer').style.display = 'none';
            } catch (e) {
                console.error("Error calculating metrics:", e);
                document.getElementById('metricsOutput').textContent = "Error calculating metrics: " + e.message;
                document.getElementById('metricsOutput').style.display = 'block';
                showTableBtn.style.display = 'none';
                document.getElementById('metricsTableContainer').style.display = 'none';
            }
        }
        function generateMetricsTable() {
            if (!datasetMap || datasetMap.size < 2) {
                alert('請至少上傳兩個前緣檔案以顯示指標表格！');
                return;
            }
            if (!checkAllNames()) {
                alert('請先為所有前緣輸入名稱！');
                return;
            }
            const rawData = {};
            datasetMap.forEach((value, key) => {
                rawData[key] = {
                    risk: value.data.map(d => d.x),
                    profit: value.data.map(d => d.y)
                };
            });
            const combinedFrontData = combineNonDominatedSets(datasetMap);
            rawData["Combined Front"] = {
                risk: combinedFrontData.risk,
                profit: combinedFrontData.profit
            };
            const normalized = normalize(rawData);
            const HV = calcHV(normalized);
            const GD = calcGD(normalized, "Combined Front");
            const IGD = calcIGD(normalized, "Combined Front");
            const hitRateResult = calculateHitRate(normalized);
            const hitRate = hitRateResult.percentages;
            const hitCounts = hitRateResult.counts;
            const combinedHV = HV["Combined Front"];
            const HVR = {};
            for (const name in HV) {
                HVR[name] = combinedHV > 0 ? (HV[name] / combinedHV) * 100 : 0;
            }
            const tableBody = document.getElementById('metricsTable').querySelector('tbody');
            tableBody.innerHTML = '';
            const metricsData = [];
            let combinedFrontMetrics = null;
            for (const name in normalized) {
                const pointCount = name === "Combined Front" ?
                    combinedFrontData.risk.length :
                    datasetMap.get(name)?.data.length || 0;
                const data = {
                    fileName: name,
                    customName: name === "Combined Front" ? "Combined" : datasetMap.get(name)?.name || name,
                    points: pointCount,
                    hv: HV[name],
                    gd: GD[name],
                    igd: IGD[name],
                    hvRate: HVR[name],
                    hitRate: hitRate[name]
                };
                if (name === "Combined Front") {
                    combinedFrontMetrics = data;
                } else {
                    metricsData.push(data);
                }
            }
            const maxNDS = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.points)) : 0;
            const maxHV = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.hv)) : 0;
            const minGD = metricsData.length > 0 ? Math.min(...metricsData.map(d => d.gd)) : Infinity;
            const minIGD = metricsData.length > 0 ? Math.min(...metricsData.map(d => d.igd)) : Infinity;
            const maxHVRate = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.hvRate)) : 0;
            const maxHitRate = metricsData.length > 0 ? Math.max(...metricsData.map(d => d.hitRate)) : 0;
            metricsData.forEach(data => {
                const hitCount = hitCounts[data.fileName] || { hits: 0, total: 0 };
                const row = document.createElement('tr');
                row.innerHTML = `
          <td>${data.customName}</td>
          <td class="${data.points === maxNDS ? 'best' : ''}">${data.points}</td>
          <td class="${data.hv === maxHV ? 'best' : ''}">${data.hv.toFixed(4)}</td>
          <td class="${data.hvRate === maxHVRate ? 'best' : ''}">${data.hvRate.toFixed(2)}%</td>
          <td class="${data.hitRate === maxHitRate ? 'best' : ''}">
            ${data.hitRate.toFixed(2)}%
            <span style="font-size: 0.7em; vertical-align: middle;">
              \\( \\frac{${hitCount.hits}}{${hitCount.total}} \\)
            </span>
          </td>
          <td class="${data.gd === minGD ? 'best' : ''}">${formatScientific(data.gd, 2)}</td>
          <td class="${data.igd === minIGD ? 'best' : ''}">${formatScientific(data.igd, 2)}</td>
        `;
                tableBody.appendChild(row);
            });
            if (combinedFrontMetrics) {
                const hitCount = hitCounts[combinedFrontMetrics.fileName] || { hits: 0, total: 0 };
                const row = document.createElement('tr');
                row.className = 'combined-front';
                row.innerHTML = `
          <td>${combinedFrontMetrics.customName}</td>
          <td>${combinedFrontMetrics.points}</td>
          <td>${combinedFrontMetrics.hv.toFixed(4)}</td>
          <td>${combinedFrontMetrics.hvRate.toFixed(2)}%</td>
          <td>
            ${combinedFrontMetrics.hitRate.toFixed(2)}%
            <span style="font-size: 0.7em; vertical-align: middle;">
              \\( \\frac{${hitCount.hits}}{${hitCount.total}} \\)
            </span>
          </td>
          <td>${formatScientific(combinedFrontMetrics.gd, 2)}</td>
          <td>${formatScientific(combinedFrontMetrics.igd, 2)}</td>
        `;
                tableBody.appendChild(row);
            }
            document.getElementById('metricsTableContainer').style.display = 'block';
            if (window.MathJax) {
                MathJax.typeset();
            }
        }
        document.getElementById('showTableBtn').addEventListener('click', generateMetricsTable);
        // 替換為載入按鈕的事件監聽器
        document.getElementById('loadFilesBtn').addEventListener('click', loadFilesFromData);
        function formatScientific(number, digits) {
            const str = number.toExponential(digits);
            const parts = str.split('e');
            const coefficient = parts[0];
            const exponentNum = parseInt(parts[1], 10);
            const sign = exponentNum >= 0 ? '+' : '-';
            const exponent = sign + Math.abs(exponentNum).toString().padStart(2, '0');
            return `${coefficient}E${exponent}`;
        }
        // Add this before addFileEntryUI
        let modalCounter = 0;

        function addFileEntryUI(fileName, defaultColor) {
            const container = document.getElementById('fileListContainer');
            const entry = document.createElement('div');
            entry.className = 'file-entry';
            entry.id = `entry-${CSS.escape(fileName)}`;

            // Create color preview box
            const colorPreview = document.createElement('div');
            colorPreview.className = 'color-preview-box';
            colorPreview.style.backgroundColor = defaultColor;
            colorPreview.title = '點擊選擇顏色';

            // Generate unique modal ID
            const modalId = `color-picker-${modalCounter++}`;

            // Create modal for color picker
            const modal = document.createElement('div');
            modal.className = 'color-picker-modal';
            modal.style.display = 'none';
            modal.innerHTML = `
        <div class="color-picker-tabs">
          <button data-tab="common" class="active">常用顏色</button>
          <button data-tab="hexrgb">HEX & RGB</button>
          <button data-tab="native">原生選擇器</button>
        </div>
        <div class="color-picker-content active" id="${modalId}-common">
          <div class="common-colors">
            ${[
                    ['#C00000', '#FF0000', '#FFC000', '#FFFF00', '#92D050', '#00B050', '#5B9BD5', '#4472C4', '#002060', '#7030A0'],
                    ['#FFE6E6', '#FF6666', '#FFF2CC', '#FFFF99', '#CCFF99', '#99FFCC', '#B3CDEB', '#A3BFFA', '#99A3CC', '#C2A3CC'],
                    ['#FFCCCC', '#FF3333', '#FFE699', '#FFFF66', '#B3E67A', '#66FF99', '#99BCE2', '#8AA7FA', '#667AB3', '#AD80BF'],
                    ['#FF9999', '#CC0000', '#FFD966', '#CCCC00', '#8CCB5E', '#33CC66', '#7FAAD8', '#7088F5', '#335099', '#985EAD'],
                    ['#B30000', '#990000', '#BF9000', '#999900', '#6B9B44', '#26994D', '#4C739B', '#3957A6', '#263C66', '#5E3A73']
                    /*['#C00000', '#FFE6E6', '#FFCCCC', '#FF9999', '#B30000'],
                    ['#FF0000', '#FF6666', '#FF3333', '#CC0000', '#990000'],
                    ['#FFC000', '#FFF2CC', '#FFE699', '#FFD966', '#BF9000'],
                    ['#FFFF00', '#FFFF99', '#FFFF66', '#CCCC00', '#999900'],
                    ['#92D050', '#CCFF99', '#B3E67A', '#8CCB5E', '#6B9B44'],
                    ['#00B050', '#99FFCC', '#66FF99', '#33CC66', '#26994D'],
                    ['#5B9BD5', '#B3CDEB', '#99BCE2', '#7FAAD8', '#4C739B'],
                    ['#4472C4', '#A3BFFA', '#8AA7FA', '#7088F5', '#3957A6'],
                    ['#002060', '#99A3CC', '#667AB3', '#335099', '#263C66'],
                    ['#7030A0', '#C2A3CC', '#AD80BF', '#985EAD', '#5E3A73']*/
                ].map(column => column.map(color => `<div class="color-swatch" style="background-color: ${color};" data-color="${color}"></div>`).join('')).join('')}
          </div>
        </div>
        
        <div class="color-picker-content" id="${modalId}-hexrgb">
          <div class="hexrgb-inputs">
            <label>紅:
              <input type="range" min="0" max="255" value="${parseInt(defaultColor.slice(1, 3), 16)}" class="rgb-slider">
              <input type="number" min="0" max="255" value="${parseInt(defaultColor.slice(1, 3), 16)}" class="rgb-number">
            </label>
            <label>綠:
              <input type="range" min="0" max="255" value="${parseInt(defaultColor.slice(3, 5), 16)}" class="rgb-slider">
              <input type="number" min="0" max="255" value="${parseInt(defaultColor.slice(3, 5), 16)}" class="rgb-number">
            </label>
            <label>藍:
              <input type="range" min="0" max="255" value="${parseInt(defaultColor.slice(5, 7), 16)}" class="rgb-slider">
              <input type="number" min="0" max="255" value="${parseInt(defaultColor.slice(5, 7), 16)}" class="rgb-number">
            </label>
            <div style="display: flex; align-items: center; gap: 8px;">
              <div class="color-preview-box live-preview" style="background-color: ${defaultColor}; opacity: 1; width: 24px; height: 24px; border: 1px solid #ccc;"></div>
              <span style="font-size: 0.85em;">十六進位表示</span>
              <input type="text" class="hex-input" placeholder="#FFFFFF" value="${defaultColor}" style="width: 100px;">
            </div>

            <label>不透明度:
              <input type="range" min="0" max="1" step="0.01" value="1" class="opacity-slider">
              <input type="number" min="0" max="1" step="0.01" value="1" class="opacity-number">
            </label>
            
            <button class="confirm-btn">確認</button>
          </div>
        </div>
        <div class="color-picker-content" id="${modalId}-native">
          <input type="color" class="native-color-input" value="${defaultColor}" style="width: 115px; height: 40px; border: none; outline: none; cursor: pointer; background: transparent; padding: 0;">
        </div>
      </div>
      `;

            // Append modal to entry to ensure it's in the DOM
            entry.appendChild(modal);

            // Tab switching logic
            const tabs = modal.querySelectorAll('.color-picker-tabs button');
            const contents = modal.querySelectorAll('.color-picker-content');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    contents.forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    const content = modal.querySelector(`#${modalId}-${tab.dataset.tab}`);
                    if (content) {
                        content.classList.add('active');
                    } else {
                        console.error(`Content element #${modalId}-${tab.dataset.tab} not found`);
                    }
                });
            });

            // 在這裡添加顏色色塊的事件監聽器代碼
            const colorSwatches = modal.querySelectorAll('.color-swatch');
            colorSwatches.forEach(swatch => {
                swatch.addEventListener('click', () => {
                    const color = swatch.getAttribute('data-color');
                    updateColor(color);
                });
            });

            const updateColor = (hex, opacity = 1) => {
                datasetMap.get(fileName).color = hex;
                datasetMap.get(fileName).opacity = opacity;
                colorPreview.style.backgroundColor = hex;
                drawChart();
                modal.style.display = 'none';
            };

            // Native color picker
            // Native color picker
            const nativeColorInput = modal.querySelector(`#${modalId}-native .native-color-input`);

            // 監聽兩種事件
            const updateFromNativeInput = () => {
                updateColor(nativeColorInput.value);
                // Update HEX & RGB tab inputs to reflect the selected color
                const hex = nativeColorInput.value;
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                const hexInput = modal.querySelector(`#${modalId}-hexrgb .hex-input`);
                const rgbSliders = modal.querySelectorAll(`#${modalId}-hexrgb .rgb-slider`);
                const rgbNumbers = modal.querySelectorAll(`#${modalId}-hexrgb .rgb-number`);
                const livePreview = modal.querySelector(`#${modalId}-hexrgb .live-preview`);
                hexInput.value = hex;
                rgbSliders[0].value = r;
                rgbSliders[1].value = g;
                rgbSliders[2].value = b;
                rgbNumbers[0].value = r;
                rgbNumbers[1].value = g;
                rgbNumbers[2].value = b;
                livePreview.style.backgroundColor = hex;
                livePreview.style.opacity = 1;
            };

            // 同時監聽 input 和 change 事件
            nativeColorInput.addEventListener('input', updateFromNativeInput);
            nativeColorInput.addEventListener('change', updateFromNativeInput);

            // ... (color-swatch, hexrgb input event listeners remain unchanged)

            // HEX & RGB inputs
            const hexInput = modal.querySelector(`#${modalId}-hexrgb .hex-input`);
            const rgbSliders = modal.querySelectorAll(`#${modalId}-hexrgb .rgb-slider`);
            const rgbNumbers = modal.querySelectorAll(`#${modalId}-hexrgb .rgb-number`);
            const opacitySlider = modal.querySelector(`#${modalId}-hexrgb .opacity-slider`);
            const opacityNumber = modal.querySelector(`#${modalId}-hexrgb .opacity-number`);
            const confirmBtn = modal.querySelector(`#${modalId}-hexrgb .confirm-btn`);

            const livePreview = modal.querySelector('.live-preview');

            const updatePreview = () => {
                const r = parseInt(rgbNumbers[0].value) || 0;
                const g = parseInt(rgbNumbers[1].value) || 0;
                const b = parseInt(rgbNumbers[2].value) || 0;
                const a = parseFloat(opacityNumber.value) || 1;
                if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255 && a >= 0 && a <= 1) {
                    const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    livePreview.style.backgroundColor = hex;
                    livePreview.style.opacity = a;
                }
            };

            const updateFromHex = () => {
                const value = hexInput.value.trim();
                if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
                    const r = parseInt(value.slice(1, 3), 16);
                    const g = parseInt(value.slice(3, 5), 16);
                    const b = parseInt(value.slice(5, 7), 16);
                    rgbSliders[0].value = r;
                    rgbSliders[1].value = g;
                    rgbSliders[2].value = b;
                    rgbNumbers[0].value = r;
                    rgbNumbers[1].value = g;
                    rgbNumbers[2].value = b;
                    updatePreview();
                }
            };

            const updateFromRGB = () => {
                const r = parseInt(rgbNumbers[0].value) || 0;
                const g = parseInt(rgbNumbers[1].value) || 0;
                const b = parseInt(rgbNumbers[2].value) || 0;
                const a = parseFloat(opacityNumber.value) || 1;
                if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255 && a >= 0 && a <= 1) {
                    const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    hexInput.value = hex;
                    rgbSliders[0].value = r;
                    rgbSliders[1].value = g;
                    rgbSliders[2].value = b;
                    updatePreview();
                }
            };

            const syncSliderAndNumber = (slider, number) => {
                slider.addEventListener('input', () => {
                    number.value = slider.value;
                    updateFromRGB();
                });
                number.addEventListener('input', () => {
                    slider.value = number.value;
                    updateFromRGB();
                });
                number.addEventListener('keypress', e => {
                    if (e.key === 'Enter') updateFromRGB();
                });
            };

            syncSliderAndNumber(rgbSliders[0], rgbNumbers[0]);
            syncSliderAndNumber(rgbSliders[1], rgbNumbers[1]);
            syncSliderAndNumber(rgbSliders[2], rgbNumbers[2]);
            syncSliderAndNumber(opacitySlider, opacityNumber);

            hexInput.addEventListener('input', updateFromHex);
            hexInput.addEventListener('keypress', e => {
                if (e.key === 'Enter') updateFromHex();
            });

            // Confirm button logic
            confirmBtn.addEventListener('click', () => {
                const r = parseInt(rgbNumbers[0].value) || 0;
                const g = parseInt(rgbNumbers[1].value) || 0;
                const b = parseInt(rgbNumbers[2].value) || 0;
                const a = parseFloat(opacityNumber.value) || 1;
                if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255 && a >= 0 && a <= 1) {
                    const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    updateColor(hex, a);
                }
            });

            // Toggle modal on preview click
            colorPreview.addEventListener('click', (e) => {
                e.stopPropagation();
                // Close all other modals
                document.querySelectorAll('.color-picker-modal').forEach(m => {
                    if (m !== modal) m.style.display = 'none';
                });
                modal.style.display = modal.style.display === 'none' ? 'block' : 'none';
                modal.style.left = `${e.pageX}px`;
                modal.style.top = `${e.pageY + 10}px`;
            });

            // Close modal when clicking outside
            document.addEventListener('click', (e) => {
                if (!modal.contains(e.target) && e.target !== colorPreview) {
                    modal.style.display = 'none';
                }
            }, { once: false });

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.style.width = '80px';
            nameInput.placeholder = '前緣名稱';
            nameInput.value = datasetMap.get(fileName).name || '';
            nameInput.addEventListener('blur', () => {
                datasetMap.get(fileName).name = nameInput.value.trim();
                drawChart();
            });
            nameInput.addEventListener('keypress', e => {
                if (e.key === 'Enter') {
                    nameInput.blur();
                }
            });

            const delBtn = document.createElement('button');
            delBtn.textContent = '刪除';
            delBtn.onclick = () => {
                datasetMap.delete(fileName);
                entry.remove();
                drawChart();
            };

            entry.appendChild(colorPreview);
            entry.appendChild(nameInput);
            entry.appendChild(document.createTextNode(fileName));
            entry.appendChild(delBtn);
            container.appendChild(entry);
            document.getElementById('resetColorsBtn').style.display = datasetMap.size > 0 ? 'inline-block' : 'none';
        }
        function drawChart() {
            const ctx = document.getElementById('riskProfitChart').getContext('2d');
            if (chartInstance) chartInstance.destroy();
            combinedFront = datasetMap.size >= 2 ? combineNonDominatedSets(datasetMap) : null;
            const datasets = Array.from(datasetMap.entries()).map(([fileName, { data, color, name }]) => ({
                label: name || fileName,
                data: data,
                backgroundColor: color,
                borderColor: color,
                pointRadius: 5,
                showLine: true,
                fill: false,
                tension: 0
            }));
            if (combinedFront && combinedFront.risk.length > 0) {
                const combinedData = [];
                for (let i = 0; i < combinedFront.risk.length; i++) {
                    combinedData.push({
                        x: combinedFront.risk[i],
                        y: combinedFront.profit[i]
                    });
                }
                datasets.push({
                    label: 'Combined Front',
                    data: combinedData,
                    backgroundColor: '#000000',
                    borderColor: '#000000',
                    pointRadius: 5,
                    showLine: true,
                    fill: false,
                    tension: 0,
                    borderWidth: 2,
                    borderDash: [5, 5]
                });
            }
            const minX = parseFloat(minRiskInput.value);
            const maxX = parseFloat(maxRiskInput.value);
            const minY = parseFloat(minProfitInput.value);
            const maxY = parseFloat(maxProfitInput.value);
            const xMin = isNaN(minX) ? undefined : minX;
            const xMax = isNaN(maxX) ? undefined : maxX;
            const yMin = isNaN(minY) ? undefined : minY;
            const yMax = isNaN(maxY) ? undefined : maxY;
            chartInstance = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Compared of Multiple Algorithms',
                            font: {
                                family: 'Times New Roman',
                                size: 32,
                                weight: 'bold'
                            }
                        },
                        tooltip: {
                            titleFont: {
                                family: 'Times New Roman',
                                size: 14
                            },
                            bodyFont: {
                                family: 'Times New Roman',
                                size: 14
                            },
                            callbacks: {
                                label: function (context) {
                                    const label = context.dataset.label;
                                    const x = context.parsed.x.toFixed(2);
                                    const y = context.parsed.y.toFixed(2);
                                    return `${label}: (${x}, ${y})`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                font: {
                                    family: 'Times New Roman',
                                    size: 14,
                                    weight: 'bold'
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                threshold: 5,
                            },
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                mode: 'xy',
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Daily Risk',
                                font: {
                                    family: 'Times New Roman',
                                    size: 24,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                font: {
                                    family: 'Times New Roman',
                                    size: 20,
                                    weight: 'bold'
                                }
                            },
                            min: xMin,
                            max: xMax
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Daily Expected Return',
                                font: {
                                    family: 'Times New Roman',
                                    size: 20,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                font: {
                                    family: 'Times New Roman',
                                    size: 20,
                                    weight: 'bold'
                                }
                            },
                            min: yMin,
                            max: yMax
                        }
                    }
                }
            });
            document.getElementById('chart-container').style.display = 'block';
            document.getElementById('chart-container').style.margin = '20px auto';
            document.getElementById('chart-container').addEventListener('dblclick', function () {
                chartInstance.resetZoom();
            });
            calculateMetrics();
            document.getElementById('resetColorsBtn').style.display = datasetMap.size > 0 ? 'inline-block' : 'none';
        }
    </script>
</body>

</html>